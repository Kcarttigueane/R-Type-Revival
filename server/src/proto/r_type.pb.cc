// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: r_type.proto

#include "r_type.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace rtype {
constexpr Event::Event(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : event_(0)
{}
struct EventDefaultTypeInternal {
  constexpr EventDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EventDefaultTypeInternal() {}
  union {
    Event _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EventDefaultTypeInternal _Event_default_instance_;
constexpr PlayerState::PlayerState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : player_id_(0u)
  , pos_x_(0)
  , pos_y_(0)
  , health_(0)
  , is_shooting_(false){}
struct PlayerStateDefaultTypeInternal {
  constexpr PlayerStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlayerStateDefaultTypeInternal() {}
  union {
    PlayerState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlayerStateDefaultTypeInternal _PlayerState_default_instance_;
constexpr EnemyState::EnemyState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , enemy_id_(0u)
  , pos_x_(0)
  , pos_y_(0)
  , health_(0){}
struct EnemyStateDefaultTypeInternal {
  constexpr EnemyStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EnemyStateDefaultTypeInternal() {}
  union {
    EnemyState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EnemyStateDefaultTypeInternal _EnemyState_default_instance_;
constexpr PowerUpState::PowerUpState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , power_up_id_(0u)
  , pos_x_(0)
  , pos_y_(0){}
struct PowerUpStateDefaultTypeInternal {
  constexpr PowerUpStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PowerUpStateDefaultTypeInternal() {}
  union {
    PowerUpState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PowerUpStateDefaultTypeInternal _PowerUpState_default_instance_;
constexpr ScoreUpdate::ScoreUpdate(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : player_id_(0u)
  , score_(0){}
struct ScoreUpdateDefaultTypeInternal {
  constexpr ScoreUpdateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ScoreUpdateDefaultTypeInternal() {}
  union {
    ScoreUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ScoreUpdateDefaultTypeInternal _ScoreUpdate_default_instance_;
constexpr BulletState::BulletState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : bullet_id_(0u)
  , pos_x_(0)
  , pos_y_(0)
  , direction_x_(0)
  , direction_y_(0)
  , speed_(0)
  , owner_id_(0u){}
struct BulletStateDefaultTypeInternal {
  constexpr BulletStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BulletStateDefaultTypeInternal() {}
  union {
    BulletState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BulletStateDefaultTypeInternal _BulletState_default_instance_;
constexpr GameState::GameState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : players_()
  , enemies_()
  , power_ups_()
  , scores_()
  , bullets_()
  , timestamp_(uint64_t{0u}){}
struct GameStateDefaultTypeInternal {
  constexpr GameStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameStateDefaultTypeInternal() {}
  union {
    GameState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameStateDefaultTypeInternal _GameState_default_instance_;
constexpr Connect::Connect(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : player_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct ConnectDefaultTypeInternal {
  constexpr ConnectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConnectDefaultTypeInternal() {}
  union {
    Connect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConnectDefaultTypeInternal _Connect_default_instance_;
constexpr ConnectResponse::ConnectResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : player_id_(0u){}
struct ConnectResponseDefaultTypeInternal {
  constexpr ConnectResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConnectResponseDefaultTypeInternal() {}
  union {
    ConnectResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConnectResponseDefaultTypeInternal _ConnectResponse_default_instance_;
constexpr Payload::Payload(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sequence_number_(0u)
  , _oneof_case_{}{}
struct PayloadDefaultTypeInternal {
  constexpr PayloadDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PayloadDefaultTypeInternal() {}
  union {
    Payload _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PayloadDefaultTypeInternal _Payload_default_instance_;
}  // namespace rtype
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_r_5ftype_2eproto[10];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_r_5ftype_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_r_5ftype_2eproto = nullptr;

const uint32_t TableStruct_r_5ftype_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::rtype::Event, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::rtype::Event, event_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::rtype::PlayerState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::rtype::PlayerState, player_id_),
  PROTOBUF_FIELD_OFFSET(::rtype::PlayerState, pos_x_),
  PROTOBUF_FIELD_OFFSET(::rtype::PlayerState, pos_y_),
  PROTOBUF_FIELD_OFFSET(::rtype::PlayerState, health_),
  PROTOBUF_FIELD_OFFSET(::rtype::PlayerState, is_shooting_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::rtype::EnemyState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::rtype::EnemyState, enemy_id_),
  PROTOBUF_FIELD_OFFSET(::rtype::EnemyState, pos_x_),
  PROTOBUF_FIELD_OFFSET(::rtype::EnemyState, pos_y_),
  PROTOBUF_FIELD_OFFSET(::rtype::EnemyState, type_),
  PROTOBUF_FIELD_OFFSET(::rtype::EnemyState, health_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::rtype::PowerUpState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::rtype::PowerUpState, power_up_id_),
  PROTOBUF_FIELD_OFFSET(::rtype::PowerUpState, pos_x_),
  PROTOBUF_FIELD_OFFSET(::rtype::PowerUpState, pos_y_),
  PROTOBUF_FIELD_OFFSET(::rtype::PowerUpState, type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::rtype::ScoreUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::rtype::ScoreUpdate, player_id_),
  PROTOBUF_FIELD_OFFSET(::rtype::ScoreUpdate, score_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::rtype::BulletState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::rtype::BulletState, bullet_id_),
  PROTOBUF_FIELD_OFFSET(::rtype::BulletState, pos_x_),
  PROTOBUF_FIELD_OFFSET(::rtype::BulletState, pos_y_),
  PROTOBUF_FIELD_OFFSET(::rtype::BulletState, direction_x_),
  PROTOBUF_FIELD_OFFSET(::rtype::BulletState, direction_y_),
  PROTOBUF_FIELD_OFFSET(::rtype::BulletState, speed_),
  PROTOBUF_FIELD_OFFSET(::rtype::BulletState, owner_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::rtype::GameState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::rtype::GameState, players_),
  PROTOBUF_FIELD_OFFSET(::rtype::GameState, enemies_),
  PROTOBUF_FIELD_OFFSET(::rtype::GameState, power_ups_),
  PROTOBUF_FIELD_OFFSET(::rtype::GameState, scores_),
  PROTOBUF_FIELD_OFFSET(::rtype::GameState, bullets_),
  PROTOBUF_FIELD_OFFSET(::rtype::GameState, timestamp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::rtype::Connect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::rtype::Connect, player_name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::rtype::ConnectResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::rtype::ConnectResponse, player_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::rtype::Payload, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::rtype::Payload, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::rtype::Payload, sequence_number_),
  PROTOBUF_FIELD_OFFSET(::rtype::Payload, payload_type_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::rtype::Event)},
  { 7, -1, -1, sizeof(::rtype::PlayerState)},
  { 18, -1, -1, sizeof(::rtype::EnemyState)},
  { 29, -1, -1, sizeof(::rtype::PowerUpState)},
  { 39, -1, -1, sizeof(::rtype::ScoreUpdate)},
  { 47, -1, -1, sizeof(::rtype::BulletState)},
  { 60, -1, -1, sizeof(::rtype::GameState)},
  { 72, -1, -1, sizeof(::rtype::Connect)},
  { 79, -1, -1, sizeof(::rtype::ConnectResponse)},
  { 86, -1, -1, sizeof(::rtype::Payload)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::rtype::_Event_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::rtype::_PlayerState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::rtype::_EnemyState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::rtype::_PowerUpState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::rtype::_ScoreUpdate_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::rtype::_BulletState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::rtype::_GameState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::rtype::_Connect_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::rtype::_ConnectResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::rtype::_Payload_default_instance_),
};

const char descriptor_table_protodef_r_5ftype_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\014r_type.proto\022\005rtype\"(\n\005Event\022\037\n\005event\030"
  "\001 \001(\0162\020.rtype.EventType\"c\n\013PlayerState\022\021"
  "\n\tplayer_id\030\001 \001(\r\022\r\n\005pos_x\030\002 \001(\002\022\r\n\005pos_"
  "y\030\003 \001(\002\022\016\n\006health\030\005 \001(\002\022\023\n\013is_shooting\030\006"
  " \001(\010\"Z\n\nEnemyState\022\020\n\010enemy_id\030\001 \001(\r\022\r\n\005"
  "pos_x\030\002 \001(\002\022\r\n\005pos_y\030\003 \001(\002\022\014\n\004type\030\004 \001(\t"
  "\022\016\n\006health\030\005 \001(\002\"O\n\014PowerUpState\022\023\n\013powe"
  "r_up_id\030\001 \001(\r\022\r\n\005pos_x\030\002 \001(\002\022\r\n\005pos_y\030\003 "
  "\001(\002\022\014\n\004type\030\004 \001(\t\"/\n\013ScoreUpdate\022\021\n\tplay"
  "er_id\030\001 \001(\r\022\r\n\005score\030\002 \001(\005\"\211\001\n\013BulletSta"
  "te\022\021\n\tbullet_id\030\001 \001(\r\022\r\n\005pos_x\030\002 \001(\002\022\r\n\005"
  "pos_y\030\003 \001(\002\022\023\n\013direction_x\030\004 \001(\002\022\023\n\013dire"
  "ction_y\030\005 \001(\002\022\r\n\005speed\030\006 \001(\002\022\020\n\010owner_id"
  "\030\007 \001(\r\"\330\001\n\tGameState\022#\n\007players\030\001 \003(\0132\022."
  "rtype.PlayerState\022\"\n\007enemies\030\002 \003(\0132\021.rty"
  "pe.EnemyState\022&\n\tpower_ups\030\003 \003(\0132\023.rtype"
  ".PowerUpState\022\"\n\006scores\030\004 \003(\0132\022.rtype.Sc"
  "oreUpdate\022#\n\007bullets\030\006 \003(\0132\022.rtype.Bulle"
  "tState\022\021\n\ttimestamp\030\005 \001(\004\"\036\n\007Connect\022\023\n\013"
  "player_name\030\001 \001(\t\"$\n\017ConnectResponse\022\021\n\t"
  "player_id\030\001 \001(\r\"\320\001\n\007Payload\022!\n\007connect\030\001"
  " \001(\0132\016.rtype.ConnectH\000\0222\n\020connect_respon"
  "se\030\002 \001(\0132\026.rtype.ConnectResponseH\000\022\035\n\005ev"
  "ent\030\003 \001(\0132\014.rtype.EventH\000\022&\n\ngame_state\030"
  "\004 \001(\0132\020.rtype.GameStateH\000\022\027\n\017sequence_nu"
  "mber\030\005 \001(\rB\016\n\014payload_type*[\n\tEventType\022"
  "\013\n\007MOVE_UP\020\000\022\r\n\tMOVE_DOWN\020\001\022\r\n\tMOVE_LEFT"
  "\020\002\022\016\n\nMOVE_RIGHT\020\003\022\t\n\005SHOOT\020\004\022\010\n\004QUIT\020\005b"
  "\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_r_5ftype_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_r_5ftype_2eproto = {
  false, false, 1127, descriptor_table_protodef_r_5ftype_2eproto, "r_type.proto", 
  &descriptor_table_r_5ftype_2eproto_once, nullptr, 0, 10,
  schemas, file_default_instances, TableStruct_r_5ftype_2eproto::offsets,
  file_level_metadata_r_5ftype_2eproto, file_level_enum_descriptors_r_5ftype_2eproto, file_level_service_descriptors_r_5ftype_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_r_5ftype_2eproto_getter() {
  return &descriptor_table_r_5ftype_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_r_5ftype_2eproto(&descriptor_table_r_5ftype_2eproto);
namespace rtype {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_r_5ftype_2eproto);
  return file_level_enum_descriptors_r_5ftype_2eproto[0];
}
bool EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Event::_Internal {
 public:
};

Event::Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:rtype.Event)
}
Event::Event(const Event& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  event_ = from.event_;
  // @@protoc_insertion_point(copy_constructor:rtype.Event)
}

inline void Event::SharedCtor() {
event_ = 0;
}

Event::~Event() {
  // @@protoc_insertion_point(destructor:rtype.Event)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Event::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Event::ArenaDtor(void* object) {
  Event* _this = reinterpret_cast< Event* >(object);
  (void)_this;
}
void Event::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Event::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Event::Clear() {
// @@protoc_insertion_point(message_clear_start:rtype.Event)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  event_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Event::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .rtype.EventType event = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_event(static_cast<::rtype::EventType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Event::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rtype.Event)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .rtype.EventType event = 1;
  if (this->_internal_event() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rtype.Event)
  return target;
}

size_t Event::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rtype.Event)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .rtype.EventType event = 1;
  if (this->_internal_event() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_event());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Event::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Event::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Event::GetClassData() const { return &_class_data_; }

void Event::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Event *>(to)->MergeFrom(
      static_cast<const Event &>(from));
}


void Event::MergeFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rtype.Event)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_event() != 0) {
    _internal_set_event(from._internal_event());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Event::CopyFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rtype.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {
  return true;
}

void Event::InternalSwap(Event* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(event_, other->event_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Event::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_r_5ftype_2eproto_getter, &descriptor_table_r_5ftype_2eproto_once,
      file_level_metadata_r_5ftype_2eproto[0]);
}

// ===================================================================

class PlayerState::_Internal {
 public:
};

PlayerState::PlayerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:rtype.PlayerState)
}
PlayerState::PlayerState(const PlayerState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&player_id_, &from.player_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_shooting_) -
    reinterpret_cast<char*>(&player_id_)) + sizeof(is_shooting_));
  // @@protoc_insertion_point(copy_constructor:rtype.PlayerState)
}

inline void PlayerState::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&player_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_shooting_) -
    reinterpret_cast<char*>(&player_id_)) + sizeof(is_shooting_));
}

PlayerState::~PlayerState() {
  // @@protoc_insertion_point(destructor:rtype.PlayerState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PlayerState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayerState::ArenaDtor(void* object) {
  PlayerState* _this = reinterpret_cast< PlayerState* >(object);
  (void)_this;
}
void PlayerState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlayerState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlayerState::Clear() {
// @@protoc_insertion_point(message_clear_start:rtype.PlayerState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&player_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_shooting_) -
      reinterpret_cast<char*>(&player_id_)) + sizeof(is_shooting_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float pos_x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          pos_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pos_y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          pos_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float health = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          health_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool is_shooting = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          is_shooting_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rtype.PlayerState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 player_id = 1;
  if (this->_internal_player_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_player_id(), target);
  }

  // float pos_x = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_x = this->_internal_pos_x();
  uint32_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_pos_x(), target);
  }

  // float pos_y = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_y = this->_internal_pos_y();
  uint32_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_pos_y(), target);
  }

  // float health = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_health = this->_internal_health();
  uint32_t raw_health;
  memcpy(&raw_health, &tmp_health, sizeof(tmp_health));
  if (raw_health != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_health(), target);
  }

  // bool is_shooting = 6;
  if (this->_internal_is_shooting() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_is_shooting(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rtype.PlayerState)
  return target;
}

size_t PlayerState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rtype.PlayerState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 player_id = 1;
  if (this->_internal_player_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_player_id());
  }

  // float pos_x = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_x = this->_internal_pos_x();
  uint32_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    total_size += 1 + 4;
  }

  // float pos_y = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_y = this->_internal_pos_y();
  uint32_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    total_size += 1 + 4;
  }

  // float health = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_health = this->_internal_health();
  uint32_t raw_health;
  memcpy(&raw_health, &tmp_health, sizeof(tmp_health));
  if (raw_health != 0) {
    total_size += 1 + 4;
  }

  // bool is_shooting = 6;
  if (this->_internal_is_shooting() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PlayerState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerState::GetClassData() const { return &_class_data_; }

void PlayerState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PlayerState *>(to)->MergeFrom(
      static_cast<const PlayerState &>(from));
}


void PlayerState::MergeFrom(const PlayerState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rtype.PlayerState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_player_id() != 0) {
    _internal_set_player_id(from._internal_player_id());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_x = from._internal_pos_x();
  uint32_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    _internal_set_pos_x(from._internal_pos_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_y = from._internal_pos_y();
  uint32_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    _internal_set_pos_y(from._internal_pos_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_health = from._internal_health();
  uint32_t raw_health;
  memcpy(&raw_health, &tmp_health, sizeof(tmp_health));
  if (raw_health != 0) {
    _internal_set_health(from._internal_health());
  }
  if (from._internal_is_shooting() != 0) {
    _internal_set_is_shooting(from._internal_is_shooting());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerState::CopyFrom(const PlayerState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rtype.PlayerState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerState::IsInitialized() const {
  return true;
}

void PlayerState::InternalSwap(PlayerState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerState, is_shooting_)
      + sizeof(PlayerState::is_shooting_)
      - PROTOBUF_FIELD_OFFSET(PlayerState, player_id_)>(
          reinterpret_cast<char*>(&player_id_),
          reinterpret_cast<char*>(&other->player_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_r_5ftype_2eproto_getter, &descriptor_table_r_5ftype_2eproto_once,
      file_level_metadata_r_5ftype_2eproto[1]);
}

// ===================================================================

class EnemyState::_Internal {
 public:
};

EnemyState::EnemyState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:rtype.EnemyState)
}
EnemyState::EnemyState(const EnemyState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArenaForAllocation());
  }
  ::memcpy(&enemy_id_, &from.enemy_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&health_) -
    reinterpret_cast<char*>(&enemy_id_)) + sizeof(health_));
  // @@protoc_insertion_point(copy_constructor:rtype.EnemyState)
}

inline void EnemyState::SharedCtor() {
type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&enemy_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&health_) -
    reinterpret_cast<char*>(&enemy_id_)) + sizeof(health_));
}

EnemyState::~EnemyState() {
  // @@protoc_insertion_point(destructor:rtype.EnemyState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void EnemyState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void EnemyState::ArenaDtor(void* object) {
  EnemyState* _this = reinterpret_cast< EnemyState* >(object);
  (void)_this;
}
void EnemyState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EnemyState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EnemyState::Clear() {
// @@protoc_insertion_point(message_clear_start:rtype.EnemyState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_.ClearToEmpty();
  ::memset(&enemy_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&health_) -
      reinterpret_cast<char*>(&enemy_id_)) + sizeof(health_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnemyState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 enemy_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          enemy_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float pos_x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          pos_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pos_y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          pos_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "rtype.EnemyState.type"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float health = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          health_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnemyState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rtype.EnemyState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 enemy_id = 1;
  if (this->_internal_enemy_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_enemy_id(), target);
  }

  // float pos_x = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_x = this->_internal_pos_x();
  uint32_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_pos_x(), target);
  }

  // float pos_y = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_y = this->_internal_pos_y();
  uint32_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_pos_y(), target);
  }

  // string type = 4;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "rtype.EnemyState.type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_type(), target);
  }

  // float health = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_health = this->_internal_health();
  uint32_t raw_health;
  memcpy(&raw_health, &tmp_health, sizeof(tmp_health));
  if (raw_health != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_health(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rtype.EnemyState)
  return target;
}

size_t EnemyState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rtype.EnemyState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type = 4;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // uint32 enemy_id = 1;
  if (this->_internal_enemy_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_enemy_id());
  }

  // float pos_x = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_x = this->_internal_pos_x();
  uint32_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    total_size += 1 + 4;
  }

  // float pos_y = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_y = this->_internal_pos_y();
  uint32_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    total_size += 1 + 4;
  }

  // float health = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_health = this->_internal_health();
  uint32_t raw_health;
  memcpy(&raw_health, &tmp_health, sizeof(tmp_health));
  if (raw_health != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnemyState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EnemyState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnemyState::GetClassData() const { return &_class_data_; }

void EnemyState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EnemyState *>(to)->MergeFrom(
      static_cast<const EnemyState &>(from));
}


void EnemyState::MergeFrom(const EnemyState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rtype.EnemyState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type().empty()) {
    _internal_set_type(from._internal_type());
  }
  if (from._internal_enemy_id() != 0) {
    _internal_set_enemy_id(from._internal_enemy_id());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_x = from._internal_pos_x();
  uint32_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    _internal_set_pos_x(from._internal_pos_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_y = from._internal_pos_y();
  uint32_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    _internal_set_pos_y(from._internal_pos_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_health = from._internal_health();
  uint32_t raw_health;
  memcpy(&raw_health, &tmp_health, sizeof(tmp_health));
  if (raw_health != 0) {
    _internal_set_health(from._internal_health());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnemyState::CopyFrom(const EnemyState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rtype.EnemyState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnemyState::IsInitialized() const {
  return true;
}

void EnemyState::InternalSwap(EnemyState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnemyState, health_)
      + sizeof(EnemyState::health_)
      - PROTOBUF_FIELD_OFFSET(EnemyState, enemy_id_)>(
          reinterpret_cast<char*>(&enemy_id_),
          reinterpret_cast<char*>(&other->enemy_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EnemyState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_r_5ftype_2eproto_getter, &descriptor_table_r_5ftype_2eproto_once,
      file_level_metadata_r_5ftype_2eproto[2]);
}

// ===================================================================

class PowerUpState::_Internal {
 public:
};

PowerUpState::PowerUpState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:rtype.PowerUpState)
}
PowerUpState::PowerUpState(const PowerUpState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArenaForAllocation());
  }
  ::memcpy(&power_up_id_, &from.power_up_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&pos_y_) -
    reinterpret_cast<char*>(&power_up_id_)) + sizeof(pos_y_));
  // @@protoc_insertion_point(copy_constructor:rtype.PowerUpState)
}

inline void PowerUpState::SharedCtor() {
type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&power_up_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pos_y_) -
    reinterpret_cast<char*>(&power_up_id_)) + sizeof(pos_y_));
}

PowerUpState::~PowerUpState() {
  // @@protoc_insertion_point(destructor:rtype.PowerUpState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PowerUpState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PowerUpState::ArenaDtor(void* object) {
  PowerUpState* _this = reinterpret_cast< PowerUpState* >(object);
  (void)_this;
}
void PowerUpState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PowerUpState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PowerUpState::Clear() {
// @@protoc_insertion_point(message_clear_start:rtype.PowerUpState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_.ClearToEmpty();
  ::memset(&power_up_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pos_y_) -
      reinterpret_cast<char*>(&power_up_id_)) + sizeof(pos_y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PowerUpState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 power_up_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          power_up_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float pos_x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          pos_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pos_y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          pos_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "rtype.PowerUpState.type"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PowerUpState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rtype.PowerUpState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 power_up_id = 1;
  if (this->_internal_power_up_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_power_up_id(), target);
  }

  // float pos_x = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_x = this->_internal_pos_x();
  uint32_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_pos_x(), target);
  }

  // float pos_y = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_y = this->_internal_pos_y();
  uint32_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_pos_y(), target);
  }

  // string type = 4;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "rtype.PowerUpState.type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rtype.PowerUpState)
  return target;
}

size_t PowerUpState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rtype.PowerUpState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type = 4;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // uint32 power_up_id = 1;
  if (this->_internal_power_up_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_power_up_id());
  }

  // float pos_x = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_x = this->_internal_pos_x();
  uint32_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    total_size += 1 + 4;
  }

  // float pos_y = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_y = this->_internal_pos_y();
  uint32_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PowerUpState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PowerUpState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PowerUpState::GetClassData() const { return &_class_data_; }

void PowerUpState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PowerUpState *>(to)->MergeFrom(
      static_cast<const PowerUpState &>(from));
}


void PowerUpState::MergeFrom(const PowerUpState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rtype.PowerUpState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type().empty()) {
    _internal_set_type(from._internal_type());
  }
  if (from._internal_power_up_id() != 0) {
    _internal_set_power_up_id(from._internal_power_up_id());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_x = from._internal_pos_x();
  uint32_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    _internal_set_pos_x(from._internal_pos_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_y = from._internal_pos_y();
  uint32_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    _internal_set_pos_y(from._internal_pos_y());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PowerUpState::CopyFrom(const PowerUpState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rtype.PowerUpState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PowerUpState::IsInitialized() const {
  return true;
}

void PowerUpState::InternalSwap(PowerUpState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PowerUpState, pos_y_)
      + sizeof(PowerUpState::pos_y_)
      - PROTOBUF_FIELD_OFFSET(PowerUpState, power_up_id_)>(
          reinterpret_cast<char*>(&power_up_id_),
          reinterpret_cast<char*>(&other->power_up_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PowerUpState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_r_5ftype_2eproto_getter, &descriptor_table_r_5ftype_2eproto_once,
      file_level_metadata_r_5ftype_2eproto[3]);
}

// ===================================================================

class ScoreUpdate::_Internal {
 public:
};

ScoreUpdate::ScoreUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:rtype.ScoreUpdate)
}
ScoreUpdate::ScoreUpdate(const ScoreUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&player_id_, &from.player_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&score_) -
    reinterpret_cast<char*>(&player_id_)) + sizeof(score_));
  // @@protoc_insertion_point(copy_constructor:rtype.ScoreUpdate)
}

inline void ScoreUpdate::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&player_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&score_) -
    reinterpret_cast<char*>(&player_id_)) + sizeof(score_));
}

ScoreUpdate::~ScoreUpdate() {
  // @@protoc_insertion_point(destructor:rtype.ScoreUpdate)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ScoreUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ScoreUpdate::ArenaDtor(void* object) {
  ScoreUpdate* _this = reinterpret_cast< ScoreUpdate* >(object);
  (void)_this;
}
void ScoreUpdate::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ScoreUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ScoreUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:rtype.ScoreUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&player_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&score_) -
      reinterpret_cast<char*>(&player_id_)) + sizeof(score_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScoreUpdate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 score = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScoreUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rtype.ScoreUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 player_id = 1;
  if (this->_internal_player_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_player_id(), target);
  }

  // int32 score = 2;
  if (this->_internal_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rtype.ScoreUpdate)
  return target;
}

size_t ScoreUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rtype.ScoreUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 player_id = 1;
  if (this->_internal_player_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_player_id());
  }

  // int32 score = 2;
  if (this->_internal_score() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_score());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScoreUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ScoreUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScoreUpdate::GetClassData() const { return &_class_data_; }

void ScoreUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ScoreUpdate *>(to)->MergeFrom(
      static_cast<const ScoreUpdate &>(from));
}


void ScoreUpdate::MergeFrom(const ScoreUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rtype.ScoreUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_player_id() != 0) {
    _internal_set_player_id(from._internal_player_id());
  }
  if (from._internal_score() != 0) {
    _internal_set_score(from._internal_score());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScoreUpdate::CopyFrom(const ScoreUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rtype.ScoreUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScoreUpdate::IsInitialized() const {
  return true;
}

void ScoreUpdate::InternalSwap(ScoreUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScoreUpdate, score_)
      + sizeof(ScoreUpdate::score_)
      - PROTOBUF_FIELD_OFFSET(ScoreUpdate, player_id_)>(
          reinterpret_cast<char*>(&player_id_),
          reinterpret_cast<char*>(&other->player_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ScoreUpdate::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_r_5ftype_2eproto_getter, &descriptor_table_r_5ftype_2eproto_once,
      file_level_metadata_r_5ftype_2eproto[4]);
}

// ===================================================================

class BulletState::_Internal {
 public:
};

BulletState::BulletState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:rtype.BulletState)
}
BulletState::BulletState(const BulletState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&bullet_id_, &from.bullet_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&owner_id_) -
    reinterpret_cast<char*>(&bullet_id_)) + sizeof(owner_id_));
  // @@protoc_insertion_point(copy_constructor:rtype.BulletState)
}

inline void BulletState::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&bullet_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&owner_id_) -
    reinterpret_cast<char*>(&bullet_id_)) + sizeof(owner_id_));
}

BulletState::~BulletState() {
  // @@protoc_insertion_point(destructor:rtype.BulletState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BulletState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BulletState::ArenaDtor(void* object) {
  BulletState* _this = reinterpret_cast< BulletState* >(object);
  (void)_this;
}
void BulletState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BulletState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BulletState::Clear() {
// @@protoc_insertion_point(message_clear_start:rtype.BulletState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&bullet_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&owner_id_) -
      reinterpret_cast<char*>(&bullet_id_)) + sizeof(owner_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BulletState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 bullet_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          bullet_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float pos_x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          pos_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pos_y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          pos_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float direction_x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          direction_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float direction_y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          direction_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float speed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // uint32 owner_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          owner_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BulletState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rtype.BulletState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 bullet_id = 1;
  if (this->_internal_bullet_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_bullet_id(), target);
  }

  // float pos_x = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_x = this->_internal_pos_x();
  uint32_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_pos_x(), target);
  }

  // float pos_y = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_y = this->_internal_pos_y();
  uint32_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_pos_y(), target);
  }

  // float direction_x = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_direction_x = this->_internal_direction_x();
  uint32_t raw_direction_x;
  memcpy(&raw_direction_x, &tmp_direction_x, sizeof(tmp_direction_x));
  if (raw_direction_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_direction_x(), target);
  }

  // float direction_y = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_direction_y = this->_internal_direction_y();
  uint32_t raw_direction_y;
  memcpy(&raw_direction_y, &tmp_direction_y, sizeof(tmp_direction_y));
  if (raw_direction_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_direction_y(), target);
  }

  // float speed = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_speed(), target);
  }

  // uint32 owner_id = 7;
  if (this->_internal_owner_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_owner_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rtype.BulletState)
  return target;
}

size_t BulletState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rtype.BulletState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 bullet_id = 1;
  if (this->_internal_bullet_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_bullet_id());
  }

  // float pos_x = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_x = this->_internal_pos_x();
  uint32_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    total_size += 1 + 4;
  }

  // float pos_y = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_y = this->_internal_pos_y();
  uint32_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    total_size += 1 + 4;
  }

  // float direction_x = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_direction_x = this->_internal_direction_x();
  uint32_t raw_direction_x;
  memcpy(&raw_direction_x, &tmp_direction_x, sizeof(tmp_direction_x));
  if (raw_direction_x != 0) {
    total_size += 1 + 4;
  }

  // float direction_y = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_direction_y = this->_internal_direction_y();
  uint32_t raw_direction_y;
  memcpy(&raw_direction_y, &tmp_direction_y, sizeof(tmp_direction_y));
  if (raw_direction_y != 0) {
    total_size += 1 + 4;
  }

  // float speed = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 4;
  }

  // uint32 owner_id = 7;
  if (this->_internal_owner_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_owner_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BulletState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BulletState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BulletState::GetClassData() const { return &_class_data_; }

void BulletState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BulletState *>(to)->MergeFrom(
      static_cast<const BulletState &>(from));
}


void BulletState::MergeFrom(const BulletState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rtype.BulletState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_bullet_id() != 0) {
    _internal_set_bullet_id(from._internal_bullet_id());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_x = from._internal_pos_x();
  uint32_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    _internal_set_pos_x(from._internal_pos_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pos_y = from._internal_pos_y();
  uint32_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    _internal_set_pos_y(from._internal_pos_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_direction_x = from._internal_direction_x();
  uint32_t raw_direction_x;
  memcpy(&raw_direction_x, &tmp_direction_x, sizeof(tmp_direction_x));
  if (raw_direction_x != 0) {
    _internal_set_direction_x(from._internal_direction_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_direction_y = from._internal_direction_y();
  uint32_t raw_direction_y;
  memcpy(&raw_direction_y, &tmp_direction_y, sizeof(tmp_direction_y));
  if (raw_direction_y != 0) {
    _internal_set_direction_y(from._internal_direction_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = from._internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _internal_set_speed(from._internal_speed());
  }
  if (from._internal_owner_id() != 0) {
    _internal_set_owner_id(from._internal_owner_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BulletState::CopyFrom(const BulletState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rtype.BulletState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BulletState::IsInitialized() const {
  return true;
}

void BulletState::InternalSwap(BulletState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BulletState, owner_id_)
      + sizeof(BulletState::owner_id_)
      - PROTOBUF_FIELD_OFFSET(BulletState, bullet_id_)>(
          reinterpret_cast<char*>(&bullet_id_),
          reinterpret_cast<char*>(&other->bullet_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BulletState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_r_5ftype_2eproto_getter, &descriptor_table_r_5ftype_2eproto_once,
      file_level_metadata_r_5ftype_2eproto[5]);
}

// ===================================================================

class GameState::_Internal {
 public:
};

GameState::GameState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  players_(arena),
  enemies_(arena),
  power_ups_(arena),
  scores_(arena),
  bullets_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:rtype.GameState)
}
GameState::GameState(const GameState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      players_(from.players_),
      enemies_(from.enemies_),
      power_ups_(from.power_ups_),
      scores_(from.scores_),
      bullets_(from.bullets_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  timestamp_ = from.timestamp_;
  // @@protoc_insertion_point(copy_constructor:rtype.GameState)
}

inline void GameState::SharedCtor() {
timestamp_ = uint64_t{0u};
}

GameState::~GameState() {
  // @@protoc_insertion_point(destructor:rtype.GameState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GameState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameState::ArenaDtor(void* object) {
  GameState* _this = reinterpret_cast< GameState* >(object);
  (void)_this;
}
void GameState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameState::Clear() {
// @@protoc_insertion_point(message_clear_start:rtype.GameState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  players_.Clear();
  enemies_.Clear();
  power_ups_.Clear();
  scores_.Clear();
  bullets_.Clear();
  timestamp_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .rtype.PlayerState players = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .rtype.EnemyState enemies = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_enemies(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .rtype.PowerUpState power_ups = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_power_ups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .rtype.ScoreUpdate scores = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_scores(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .rtype.BulletState bullets = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bullets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rtype.GameState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .rtype.PlayerState players = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_players_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_players(i), target, stream);
  }

  // repeated .rtype.EnemyState enemies = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_enemies_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_enemies(i), target, stream);
  }

  // repeated .rtype.PowerUpState power_ups = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_power_ups_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_power_ups(i), target, stream);
  }

  // repeated .rtype.ScoreUpdate scores = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_scores_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_scores(i), target, stream);
  }

  // uint64 timestamp = 5;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_timestamp(), target);
  }

  // repeated .rtype.BulletState bullets = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_bullets_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_bullets(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rtype.GameState)
  return target;
}

size_t GameState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rtype.GameState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .rtype.PlayerState players = 1;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .rtype.EnemyState enemies = 2;
  total_size += 1UL * this->_internal_enemies_size();
  for (const auto& msg : this->enemies_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .rtype.PowerUpState power_ups = 3;
  total_size += 1UL * this->_internal_power_ups_size();
  for (const auto& msg : this->power_ups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .rtype.ScoreUpdate scores = 4;
  total_size += 1UL * this->_internal_scores_size();
  for (const auto& msg : this->scores_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .rtype.BulletState bullets = 6;
  total_size += 1UL * this->_internal_bullets_size();
  for (const auto& msg : this->bullets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint64 timestamp = 5;
  if (this->_internal_timestamp() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GameState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameState::GetClassData() const { return &_class_data_; }

void GameState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GameState *>(to)->MergeFrom(
      static_cast<const GameState &>(from));
}


void GameState::MergeFrom(const GameState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rtype.GameState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  players_.MergeFrom(from.players_);
  enemies_.MergeFrom(from.enemies_);
  power_ups_.MergeFrom(from.power_ups_);
  scores_.MergeFrom(from.scores_);
  bullets_.MergeFrom(from.bullets_);
  if (from._internal_timestamp() != 0) {
    _internal_set_timestamp(from._internal_timestamp());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameState::CopyFrom(const GameState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rtype.GameState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameState::IsInitialized() const {
  return true;
}

void GameState::InternalSwap(GameState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  players_.InternalSwap(&other->players_);
  enemies_.InternalSwap(&other->enemies_);
  power_ups_.InternalSwap(&other->power_ups_);
  scores_.InternalSwap(&other->scores_);
  bullets_.InternalSwap(&other->bullets_);
  swap(timestamp_, other->timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_r_5ftype_2eproto_getter, &descriptor_table_r_5ftype_2eproto_once,
      file_level_metadata_r_5ftype_2eproto[6]);
}

// ===================================================================

class Connect::_Internal {
 public:
};

Connect::Connect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:rtype.Connect)
}
Connect::Connect(const Connect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  player_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    player_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_player_name().empty()) {
    player_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_player_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:rtype.Connect)
}

inline void Connect::SharedCtor() {
player_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  player_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Connect::~Connect() {
  // @@protoc_insertion_point(destructor:rtype.Connect)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Connect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  player_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Connect::ArenaDtor(void* object) {
  Connect* _this = reinterpret_cast< Connect* >(object);
  (void)_this;
}
void Connect::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Connect::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Connect::Clear() {
// @@protoc_insertion_point(message_clear_start:rtype.Connect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  player_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Connect::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string player_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_player_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "rtype.Connect.player_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Connect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rtype.Connect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string player_name = 1;
  if (!this->_internal_player_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_player_name().data(), static_cast<int>(this->_internal_player_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "rtype.Connect.player_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_player_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rtype.Connect)
  return target;
}

size_t Connect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rtype.Connect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string player_name = 1;
  if (!this->_internal_player_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_player_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Connect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Connect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Connect::GetClassData() const { return &_class_data_; }

void Connect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Connect *>(to)->MergeFrom(
      static_cast<const Connect &>(from));
}


void Connect::MergeFrom(const Connect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rtype.Connect)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_player_name().empty()) {
    _internal_set_player_name(from._internal_player_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Connect::CopyFrom(const Connect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rtype.Connect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Connect::IsInitialized() const {
  return true;
}

void Connect::InternalSwap(Connect* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &player_name_, lhs_arena,
      &other->player_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Connect::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_r_5ftype_2eproto_getter, &descriptor_table_r_5ftype_2eproto_once,
      file_level_metadata_r_5ftype_2eproto[7]);
}

// ===================================================================

class ConnectResponse::_Internal {
 public:
};

ConnectResponse::ConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:rtype.ConnectResponse)
}
ConnectResponse::ConnectResponse(const ConnectResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  player_id_ = from.player_id_;
  // @@protoc_insertion_point(copy_constructor:rtype.ConnectResponse)
}

inline void ConnectResponse::SharedCtor() {
player_id_ = 0u;
}

ConnectResponse::~ConnectResponse() {
  // @@protoc_insertion_point(destructor:rtype.ConnectResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ConnectResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConnectResponse::ArenaDtor(void* object) {
  ConnectResponse* _this = reinterpret_cast< ConnectResponse* >(object);
  (void)_this;
}
void ConnectResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConnectResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConnectResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:rtype.ConnectResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  player_id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConnectResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rtype.ConnectResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 player_id = 1;
  if (this->_internal_player_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rtype.ConnectResponse)
  return target;
}

size_t ConnectResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rtype.ConnectResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 player_id = 1;
  if (this->_internal_player_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConnectResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ConnectResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConnectResponse::GetClassData() const { return &_class_data_; }

void ConnectResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ConnectResponse *>(to)->MergeFrom(
      static_cast<const ConnectResponse &>(from));
}


void ConnectResponse::MergeFrom(const ConnectResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rtype.ConnectResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_player_id() != 0) {
    _internal_set_player_id(from._internal_player_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConnectResponse::CopyFrom(const ConnectResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rtype.ConnectResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectResponse::IsInitialized() const {
  return true;
}

void ConnectResponse::InternalSwap(ConnectResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(player_id_, other->player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ConnectResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_r_5ftype_2eproto_getter, &descriptor_table_r_5ftype_2eproto_once,
      file_level_metadata_r_5ftype_2eproto[8]);
}

// ===================================================================

class Payload::_Internal {
 public:
  static const ::rtype::Connect& connect(const Payload* msg);
  static const ::rtype::ConnectResponse& connect_response(const Payload* msg);
  static const ::rtype::Event& event(const Payload* msg);
  static const ::rtype::GameState& game_state(const Payload* msg);
};

const ::rtype::Connect&
Payload::_Internal::connect(const Payload* msg) {
  return *msg->payload_type_.connect_;
}
const ::rtype::ConnectResponse&
Payload::_Internal::connect_response(const Payload* msg) {
  return *msg->payload_type_.connect_response_;
}
const ::rtype::Event&
Payload::_Internal::event(const Payload* msg) {
  return *msg->payload_type_.event_;
}
const ::rtype::GameState&
Payload::_Internal::game_state(const Payload* msg) {
  return *msg->payload_type_.game_state_;
}
void Payload::set_allocated_connect(::rtype::Connect* connect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_type();
  if (connect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rtype::Connect>::GetOwningArena(connect);
    if (message_arena != submessage_arena) {
      connect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connect, submessage_arena);
    }
    set_has_connect();
    payload_type_.connect_ = connect;
  }
  // @@protoc_insertion_point(field_set_allocated:rtype.Payload.connect)
}
void Payload::set_allocated_connect_response(::rtype::ConnectResponse* connect_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_type();
  if (connect_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rtype::ConnectResponse>::GetOwningArena(connect_response);
    if (message_arena != submessage_arena) {
      connect_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connect_response, submessage_arena);
    }
    set_has_connect_response();
    payload_type_.connect_response_ = connect_response;
  }
  // @@protoc_insertion_point(field_set_allocated:rtype.Payload.connect_response)
}
void Payload::set_allocated_event(::rtype::Event* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_type();
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rtype::Event>::GetOwningArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    set_has_event();
    payload_type_.event_ = event;
  }
  // @@protoc_insertion_point(field_set_allocated:rtype.Payload.event)
}
void Payload::set_allocated_game_state(::rtype::GameState* game_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload_type();
  if (game_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rtype::GameState>::GetOwningArena(game_state);
    if (message_arena != submessage_arena) {
      game_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_state, submessage_arena);
    }
    set_has_game_state();
    payload_type_.game_state_ = game_state;
  }
  // @@protoc_insertion_point(field_set_allocated:rtype.Payload.game_state)
}
Payload::Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:rtype.Payload)
}
Payload::Payload(const Payload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sequence_number_ = from.sequence_number_;
  clear_has_payload_type();
  switch (from.payload_type_case()) {
    case kConnect: {
      _internal_mutable_connect()->::rtype::Connect::MergeFrom(from._internal_connect());
      break;
    }
    case kConnectResponse: {
      _internal_mutable_connect_response()->::rtype::ConnectResponse::MergeFrom(from._internal_connect_response());
      break;
    }
    case kEvent: {
      _internal_mutable_event()->::rtype::Event::MergeFrom(from._internal_event());
      break;
    }
    case kGameState: {
      _internal_mutable_game_state()->::rtype::GameState::MergeFrom(from._internal_game_state());
      break;
    }
    case PAYLOAD_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:rtype.Payload)
}

inline void Payload::SharedCtor() {
sequence_number_ = 0u;
clear_has_payload_type();
}

Payload::~Payload() {
  // @@protoc_insertion_point(destructor:rtype.Payload)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Payload::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload_type()) {
    clear_payload_type();
  }
}

void Payload::ArenaDtor(void* object) {
  Payload* _this = reinterpret_cast< Payload* >(object);
  (void)_this;
}
void Payload::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Payload::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Payload::clear_payload_type() {
// @@protoc_insertion_point(one_of_clear_start:rtype.Payload)
  switch (payload_type_case()) {
    case kConnect: {
      if (GetArenaForAllocation() == nullptr) {
        delete payload_type_.connect_;
      }
      break;
    }
    case kConnectResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete payload_type_.connect_response_;
      }
      break;
    }
    case kEvent: {
      if (GetArenaForAllocation() == nullptr) {
        delete payload_type_.event_;
      }
      break;
    }
    case kGameState: {
      if (GetArenaForAllocation() == nullptr) {
        delete payload_type_.game_state_;
      }
      break;
    }
    case PAYLOAD_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PAYLOAD_TYPE_NOT_SET;
}


void Payload::Clear() {
// @@protoc_insertion_point(message_clear_start:rtype.Payload)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sequence_number_ = 0u;
  clear_payload_type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Payload::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .rtype.Connect connect = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_connect(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .rtype.ConnectResponse connect_response = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_connect_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .rtype.Event event = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .rtype.GameState game_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sequence_number = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          sequence_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Payload::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:rtype.Payload)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .rtype.Connect connect = 1;
  if (_internal_has_connect()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::connect(this), target, stream);
  }

  // .rtype.ConnectResponse connect_response = 2;
  if (_internal_has_connect_response()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::connect_response(this), target, stream);
  }

  // .rtype.Event event = 3;
  if (_internal_has_event()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::event(this), target, stream);
  }

  // .rtype.GameState game_state = 4;
  if (_internal_has_game_state()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::game_state(this), target, stream);
  }

  // uint32 sequence_number = 5;
  if (this->_internal_sequence_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_sequence_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:rtype.Payload)
  return target;
}

size_t Payload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rtype.Payload)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 sequence_number = 5;
  if (this->_internal_sequence_number() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_sequence_number());
  }

  switch (payload_type_case()) {
    // .rtype.Connect connect = 1;
    case kConnect: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_type_.connect_);
      break;
    }
    // .rtype.ConnectResponse connect_response = 2;
    case kConnectResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_type_.connect_response_);
      break;
    }
    // .rtype.Event event = 3;
    case kEvent: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_type_.event_);
      break;
    }
    // .rtype.GameState game_state = 4;
    case kGameState: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *payload_type_.game_state_);
      break;
    }
    case PAYLOAD_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Payload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Payload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Payload::GetClassData() const { return &_class_data_; }

void Payload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Payload *>(to)->MergeFrom(
      static_cast<const Payload &>(from));
}


void Payload::MergeFrom(const Payload& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rtype.Payload)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_sequence_number() != 0) {
    _internal_set_sequence_number(from._internal_sequence_number());
  }
  switch (from.payload_type_case()) {
    case kConnect: {
      _internal_mutable_connect()->::rtype::Connect::MergeFrom(from._internal_connect());
      break;
    }
    case kConnectResponse: {
      _internal_mutable_connect_response()->::rtype::ConnectResponse::MergeFrom(from._internal_connect_response());
      break;
    }
    case kEvent: {
      _internal_mutable_event()->::rtype::Event::MergeFrom(from._internal_event());
      break;
    }
    case kGameState: {
      _internal_mutable_game_state()->::rtype::GameState::MergeFrom(from._internal_game_state());
      break;
    }
    case PAYLOAD_TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Payload::CopyFrom(const Payload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rtype.Payload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Payload::IsInitialized() const {
  return true;
}

void Payload::InternalSwap(Payload* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(sequence_number_, other->sequence_number_);
  swap(payload_type_, other->payload_type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Payload::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_r_5ftype_2eproto_getter, &descriptor_table_r_5ftype_2eproto_once,
      file_level_metadata_r_5ftype_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace rtype
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::rtype::Event* Arena::CreateMaybeMessage< ::rtype::Event >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rtype::Event >(arena);
}
template<> PROTOBUF_NOINLINE ::rtype::PlayerState* Arena::CreateMaybeMessage< ::rtype::PlayerState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rtype::PlayerState >(arena);
}
template<> PROTOBUF_NOINLINE ::rtype::EnemyState* Arena::CreateMaybeMessage< ::rtype::EnemyState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rtype::EnemyState >(arena);
}
template<> PROTOBUF_NOINLINE ::rtype::PowerUpState* Arena::CreateMaybeMessage< ::rtype::PowerUpState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rtype::PowerUpState >(arena);
}
template<> PROTOBUF_NOINLINE ::rtype::ScoreUpdate* Arena::CreateMaybeMessage< ::rtype::ScoreUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rtype::ScoreUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::rtype::BulletState* Arena::CreateMaybeMessage< ::rtype::BulletState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rtype::BulletState >(arena);
}
template<> PROTOBUF_NOINLINE ::rtype::GameState* Arena::CreateMaybeMessage< ::rtype::GameState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rtype::GameState >(arena);
}
template<> PROTOBUF_NOINLINE ::rtype::Connect* Arena::CreateMaybeMessage< ::rtype::Connect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rtype::Connect >(arena);
}
template<> PROTOBUF_NOINLINE ::rtype::ConnectResponse* Arena::CreateMaybeMessage< ::rtype::ConnectResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rtype::ConnectResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::rtype::Payload* Arena::CreateMaybeMessage< ::rtype::Payload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::rtype::Payload >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
