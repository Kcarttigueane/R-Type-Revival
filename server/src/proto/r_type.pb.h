// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: r_type.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_r_5ftype_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_r_5ftype_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_r_5ftype_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_r_5ftype_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_r_5ftype_2eproto;
namespace rtype {
class BulletState;
struct BulletStateDefaultTypeInternal;
extern BulletStateDefaultTypeInternal _BulletState_default_instance_;
class Connect;
struct ConnectDefaultTypeInternal;
extern ConnectDefaultTypeInternal _Connect_default_instance_;
class ConnectResponse;
struct ConnectResponseDefaultTypeInternal;
extern ConnectResponseDefaultTypeInternal _ConnectResponse_default_instance_;
class EnemyState;
struct EnemyStateDefaultTypeInternal;
extern EnemyStateDefaultTypeInternal _EnemyState_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class GameState;
struct GameStateDefaultTypeInternal;
extern GameStateDefaultTypeInternal _GameState_default_instance_;
class Payload;
struct PayloadDefaultTypeInternal;
extern PayloadDefaultTypeInternal _Payload_default_instance_;
class PlayerState;
struct PlayerStateDefaultTypeInternal;
extern PlayerStateDefaultTypeInternal _PlayerState_default_instance_;
class PowerUpState;
struct PowerUpStateDefaultTypeInternal;
extern PowerUpStateDefaultTypeInternal _PowerUpState_default_instance_;
class ScoreUpdate;
struct ScoreUpdateDefaultTypeInternal;
extern ScoreUpdateDefaultTypeInternal _ScoreUpdate_default_instance_;
class WaveInfo;
struct WaveInfoDefaultTypeInternal;
extern WaveInfoDefaultTypeInternal _WaveInfo_default_instance_;
}  // namespace rtype
PROTOBUF_NAMESPACE_OPEN
template<> ::rtype::BulletState* Arena::CreateMaybeMessage<::rtype::BulletState>(Arena*);
template<> ::rtype::Connect* Arena::CreateMaybeMessage<::rtype::Connect>(Arena*);
template<> ::rtype::ConnectResponse* Arena::CreateMaybeMessage<::rtype::ConnectResponse>(Arena*);
template<> ::rtype::EnemyState* Arena::CreateMaybeMessage<::rtype::EnemyState>(Arena*);
template<> ::rtype::Event* Arena::CreateMaybeMessage<::rtype::Event>(Arena*);
template<> ::rtype::GameState* Arena::CreateMaybeMessage<::rtype::GameState>(Arena*);
template<> ::rtype::Payload* Arena::CreateMaybeMessage<::rtype::Payload>(Arena*);
template<> ::rtype::PlayerState* Arena::CreateMaybeMessage<::rtype::PlayerState>(Arena*);
template<> ::rtype::PowerUpState* Arena::CreateMaybeMessage<::rtype::PowerUpState>(Arena*);
template<> ::rtype::ScoreUpdate* Arena::CreateMaybeMessage<::rtype::ScoreUpdate>(Arena*);
template<> ::rtype::WaveInfo* Arena::CreateMaybeMessage<::rtype::WaveInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rtype {

enum EventType : int {
  MOVE_UP = 0,
  MOVE_DOWN = 1,
  MOVE_LEFT = 2,
  MOVE_RIGHT = 3,
  SHOOT = 4,
  QUIT = 5,
  EventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EventType_IsValid(int value);
constexpr EventType EventType_MIN = MOVE_UP;
constexpr EventType EventType_MAX = QUIT;
constexpr int EventType_ARRAYSIZE = EventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventType_descriptor();
template<typename T>
inline const std::string& EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventType_descriptor(), enum_t_value);
}
inline bool EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventType>(
    EventType_descriptor(), name, value);
}
enum ConnectResponseStatus : int {
  SUCCESS = 0,
  SERVER_FULL = 1,
  ConnectResponseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConnectResponseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConnectResponseStatus_IsValid(int value);
constexpr ConnectResponseStatus ConnectResponseStatus_MIN = SUCCESS;
constexpr ConnectResponseStatus ConnectResponseStatus_MAX = SERVER_FULL;
constexpr int ConnectResponseStatus_ARRAYSIZE = ConnectResponseStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectResponseStatus_descriptor();
template<typename T>
inline const std::string& ConnectResponseStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectResponseStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectResponseStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectResponseStatus_descriptor(), enum_t_value);
}
inline bool ConnectResponseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectResponseStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectResponseStatus>(
    ConnectResponseStatus_descriptor(), name, value);
}
// ===================================================================

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtype.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit constexpr Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Event& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtype.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 1,
  };
  // .rtype.EventType event = 1;
  void clear_event();
  ::rtype::EventType event() const;
  void set_event(::rtype::EventType value);
  private:
  ::rtype::EventType _internal_event() const;
  void _internal_set_event(::rtype::EventType value);
  public:

  // @@protoc_insertion_point(class_scope:rtype.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_r_5ftype_2eproto;
};
// -------------------------------------------------------------------

class PlayerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtype.PlayerState) */ {
 public:
  inline PlayerState() : PlayerState(nullptr) {}
  ~PlayerState() override;
  explicit constexpr PlayerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerState(const PlayerState& from);
  PlayerState(PlayerState&& from) noexcept
    : PlayerState() {
    *this = ::std::move(from);
  }

  inline PlayerState& operator=(const PlayerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerState& operator=(PlayerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerState* internal_default_instance() {
    return reinterpret_cast<const PlayerState*>(
               &_PlayerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PlayerState& a, PlayerState& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtype.PlayerState";
  }
  protected:
  explicit PlayerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kPosXFieldNumber = 2,
    kPosYFieldNumber = 3,
    kHealthFieldNumber = 5,
    kIsShootingFieldNumber = 6,
  };
  // uint32 player_id = 1;
  void clear_player_id();
  uint32_t player_id() const;
  void set_player_id(uint32_t value);
  private:
  uint32_t _internal_player_id() const;
  void _internal_set_player_id(uint32_t value);
  public:

  // float pos_x = 2;
  void clear_pos_x();
  float pos_x() const;
  void set_pos_x(float value);
  private:
  float _internal_pos_x() const;
  void _internal_set_pos_x(float value);
  public:

  // float pos_y = 3;
  void clear_pos_y();
  float pos_y() const;
  void set_pos_y(float value);
  private:
  float _internal_pos_y() const;
  void _internal_set_pos_y(float value);
  public:

  // float health = 5;
  void clear_health();
  float health() const;
  void set_health(float value);
  private:
  float _internal_health() const;
  void _internal_set_health(float value);
  public:

  // bool is_shooting = 6;
  void clear_is_shooting();
  bool is_shooting() const;
  void set_is_shooting(bool value);
  private:
  bool _internal_is_shooting() const;
  void _internal_set_is_shooting(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rtype.PlayerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t player_id_;
  float pos_x_;
  float pos_y_;
  float health_;
  bool is_shooting_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_r_5ftype_2eproto;
};
// -------------------------------------------------------------------

class EnemyState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtype.EnemyState) */ {
 public:
  inline EnemyState() : EnemyState(nullptr) {}
  ~EnemyState() override;
  explicit constexpr EnemyState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnemyState(const EnemyState& from);
  EnemyState(EnemyState&& from) noexcept
    : EnemyState() {
    *this = ::std::move(from);
  }

  inline EnemyState& operator=(const EnemyState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnemyState& operator=(EnemyState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnemyState& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnemyState* internal_default_instance() {
    return reinterpret_cast<const EnemyState*>(
               &_EnemyState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EnemyState& a, EnemyState& b) {
    a.Swap(&b);
  }
  inline void Swap(EnemyState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnemyState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnemyState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnemyState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnemyState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnemyState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnemyState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtype.EnemyState";
  }
  protected:
  explicit EnemyState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 4,
    kEnemyIdFieldNumber = 1,
    kPosXFieldNumber = 2,
    kPosYFieldNumber = 3,
    kHealthFieldNumber = 5,
  };
  // string type = 4;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // uint32 enemy_id = 1;
  void clear_enemy_id();
  uint32_t enemy_id() const;
  void set_enemy_id(uint32_t value);
  private:
  uint32_t _internal_enemy_id() const;
  void _internal_set_enemy_id(uint32_t value);
  public:

  // float pos_x = 2;
  void clear_pos_x();
  float pos_x() const;
  void set_pos_x(float value);
  private:
  float _internal_pos_x() const;
  void _internal_set_pos_x(float value);
  public:

  // float pos_y = 3;
  void clear_pos_y();
  float pos_y() const;
  void set_pos_y(float value);
  private:
  float _internal_pos_y() const;
  void _internal_set_pos_y(float value);
  public:

  // float health = 5;
  void clear_health();
  float health() const;
  void set_health(float value);
  private:
  float _internal_health() const;
  void _internal_set_health(float value);
  public:

  // @@protoc_insertion_point(class_scope:rtype.EnemyState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  uint32_t enemy_id_;
  float pos_x_;
  float pos_y_;
  float health_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_r_5ftype_2eproto;
};
// -------------------------------------------------------------------

class PowerUpState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtype.PowerUpState) */ {
 public:
  inline PowerUpState() : PowerUpState(nullptr) {}
  ~PowerUpState() override;
  explicit constexpr PowerUpState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PowerUpState(const PowerUpState& from);
  PowerUpState(PowerUpState&& from) noexcept
    : PowerUpState() {
    *this = ::std::move(from);
  }

  inline PowerUpState& operator=(const PowerUpState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PowerUpState& operator=(PowerUpState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PowerUpState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PowerUpState* internal_default_instance() {
    return reinterpret_cast<const PowerUpState*>(
               &_PowerUpState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PowerUpState& a, PowerUpState& b) {
    a.Swap(&b);
  }
  inline void Swap(PowerUpState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PowerUpState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PowerUpState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PowerUpState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PowerUpState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PowerUpState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PowerUpState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtype.PowerUpState";
  }
  protected:
  explicit PowerUpState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 4,
    kPowerUpIdFieldNumber = 1,
    kPosXFieldNumber = 2,
    kPosYFieldNumber = 3,
  };
  // string type = 4;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // uint32 power_up_id = 1;
  void clear_power_up_id();
  uint32_t power_up_id() const;
  void set_power_up_id(uint32_t value);
  private:
  uint32_t _internal_power_up_id() const;
  void _internal_set_power_up_id(uint32_t value);
  public:

  // float pos_x = 2;
  void clear_pos_x();
  float pos_x() const;
  void set_pos_x(float value);
  private:
  float _internal_pos_x() const;
  void _internal_set_pos_x(float value);
  public:

  // float pos_y = 3;
  void clear_pos_y();
  float pos_y() const;
  void set_pos_y(float value);
  private:
  float _internal_pos_y() const;
  void _internal_set_pos_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:rtype.PowerUpState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  uint32_t power_up_id_;
  float pos_x_;
  float pos_y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_r_5ftype_2eproto;
};
// -------------------------------------------------------------------

class ScoreUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtype.ScoreUpdate) */ {
 public:
  inline ScoreUpdate() : ScoreUpdate(nullptr) {}
  ~ScoreUpdate() override;
  explicit constexpr ScoreUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScoreUpdate(const ScoreUpdate& from);
  ScoreUpdate(ScoreUpdate&& from) noexcept
    : ScoreUpdate() {
    *this = ::std::move(from);
  }

  inline ScoreUpdate& operator=(const ScoreUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScoreUpdate& operator=(ScoreUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScoreUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScoreUpdate* internal_default_instance() {
    return reinterpret_cast<const ScoreUpdate*>(
               &_ScoreUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ScoreUpdate& a, ScoreUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ScoreUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScoreUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScoreUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScoreUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScoreUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ScoreUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScoreUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtype.ScoreUpdate";
  }
  protected:
  explicit ScoreUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kScoreFieldNumber = 2,
  };
  // uint32 player_id = 1;
  void clear_player_id();
  uint32_t player_id() const;
  void set_player_id(uint32_t value);
  private:
  uint32_t _internal_player_id() const;
  void _internal_set_player_id(uint32_t value);
  public:

  // int32 score = 2;
  void clear_score();
  int32_t score() const;
  void set_score(int32_t value);
  private:
  int32_t _internal_score() const;
  void _internal_set_score(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtype.ScoreUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t player_id_;
  int32_t score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_r_5ftype_2eproto;
};
// -------------------------------------------------------------------

class WaveInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtype.WaveInfo) */ {
 public:
  inline WaveInfo() : WaveInfo(nullptr) {}
  ~WaveInfo() override;
  explicit constexpr WaveInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaveInfo(const WaveInfo& from);
  WaveInfo(WaveInfo&& from) noexcept
    : WaveInfo() {
    *this = ::std::move(from);
  }

  inline WaveInfo& operator=(const WaveInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaveInfo& operator=(WaveInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaveInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaveInfo* internal_default_instance() {
    return reinterpret_cast<const WaveInfo*>(
               &_WaveInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WaveInfo& a, WaveInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WaveInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaveInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaveInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaveInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WaveInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WaveInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaveInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtype.WaveInfo";
  }
  protected:
  explicit WaveInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentWaveFieldNumber = 1,
    kTotalEnemiesFieldNumber = 2,
    kWaveInProgressFieldNumber = 3,
  };
  // int32 current_wave = 1;
  void clear_current_wave();
  int32_t current_wave() const;
  void set_current_wave(int32_t value);
  private:
  int32_t _internal_current_wave() const;
  void _internal_set_current_wave(int32_t value);
  public:

  // int32 total_enemies = 2;
  void clear_total_enemies();
  int32_t total_enemies() const;
  void set_total_enemies(int32_t value);
  private:
  int32_t _internal_total_enemies() const;
  void _internal_set_total_enemies(int32_t value);
  public:

  // bool wave_in_progress = 3;
  void clear_wave_in_progress();
  bool wave_in_progress() const;
  void set_wave_in_progress(bool value);
  private:
  bool _internal_wave_in_progress() const;
  void _internal_set_wave_in_progress(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rtype.WaveInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t current_wave_;
  int32_t total_enemies_;
  bool wave_in_progress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_r_5ftype_2eproto;
};
// -------------------------------------------------------------------

class BulletState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtype.BulletState) */ {
 public:
  inline BulletState() : BulletState(nullptr) {}
  ~BulletState() override;
  explicit constexpr BulletState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BulletState(const BulletState& from);
  BulletState(BulletState&& from) noexcept
    : BulletState() {
    *this = ::std::move(from);
  }

  inline BulletState& operator=(const BulletState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulletState& operator=(BulletState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BulletState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BulletState* internal_default_instance() {
    return reinterpret_cast<const BulletState*>(
               &_BulletState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BulletState& a, BulletState& b) {
    a.Swap(&b);
  }
  inline void Swap(BulletState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BulletState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BulletState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BulletState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BulletState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BulletState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulletState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtype.BulletState";
  }
  protected:
  explicit BulletState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBulletIdFieldNumber = 1,
    kPosXFieldNumber = 2,
    kPosYFieldNumber = 3,
    kDirectionXFieldNumber = 4,
    kDirectionYFieldNumber = 5,
    kSpeedFieldNumber = 6,
    kOwnerIdFieldNumber = 7,
  };
  // uint32 bullet_id = 1;
  void clear_bullet_id();
  uint32_t bullet_id() const;
  void set_bullet_id(uint32_t value);
  private:
  uint32_t _internal_bullet_id() const;
  void _internal_set_bullet_id(uint32_t value);
  public:

  // float pos_x = 2;
  void clear_pos_x();
  float pos_x() const;
  void set_pos_x(float value);
  private:
  float _internal_pos_x() const;
  void _internal_set_pos_x(float value);
  public:

  // float pos_y = 3;
  void clear_pos_y();
  float pos_y() const;
  void set_pos_y(float value);
  private:
  float _internal_pos_y() const;
  void _internal_set_pos_y(float value);
  public:

  // float direction_x = 4;
  void clear_direction_x();
  float direction_x() const;
  void set_direction_x(float value);
  private:
  float _internal_direction_x() const;
  void _internal_set_direction_x(float value);
  public:

  // float direction_y = 5;
  void clear_direction_y();
  float direction_y() const;
  void set_direction_y(float value);
  private:
  float _internal_direction_y() const;
  void _internal_set_direction_y(float value);
  public:

  // float speed = 6;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // uint32 owner_id = 7;
  void clear_owner_id();
  uint32_t owner_id() const;
  void set_owner_id(uint32_t value);
  private:
  uint32_t _internal_owner_id() const;
  void _internal_set_owner_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtype.BulletState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t bullet_id_;
  float pos_x_;
  float pos_y_;
  float direction_x_;
  float direction_y_;
  float speed_;
  uint32_t owner_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_r_5ftype_2eproto;
};
// -------------------------------------------------------------------

class GameState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtype.GameState) */ {
 public:
  inline GameState() : GameState(nullptr) {}
  ~GameState() override;
  explicit constexpr GameState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameState(const GameState& from);
  GameState(GameState&& from) noexcept
    : GameState() {
    *this = ::std::move(from);
  }

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState& operator=(GameState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameState& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameState* internal_default_instance() {
    return reinterpret_cast<const GameState*>(
               &_GameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GameState& a, GameState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtype.GameState";
  }
  protected:
  explicit GameState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
    kEnemiesFieldNumber = 2,
    kPowerUpsFieldNumber = 3,
    kScoresFieldNumber = 4,
    kBulletsFieldNumber = 6,
    kWaveInfoFieldNumber = 7,
    kTimestampFieldNumber = 5,
  };
  // repeated .rtype.PlayerState players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::rtype::PlayerState* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::PlayerState >*
      mutable_players();
  private:
  const ::rtype::PlayerState& _internal_players(int index) const;
  ::rtype::PlayerState* _internal_add_players();
  public:
  const ::rtype::PlayerState& players(int index) const;
  ::rtype::PlayerState* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::PlayerState >&
      players() const;

  // repeated .rtype.EnemyState enemies = 2;
  int enemies_size() const;
  private:
  int _internal_enemies_size() const;
  public:
  void clear_enemies();
  ::rtype::EnemyState* mutable_enemies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::EnemyState >*
      mutable_enemies();
  private:
  const ::rtype::EnemyState& _internal_enemies(int index) const;
  ::rtype::EnemyState* _internal_add_enemies();
  public:
  const ::rtype::EnemyState& enemies(int index) const;
  ::rtype::EnemyState* add_enemies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::EnemyState >&
      enemies() const;

  // repeated .rtype.PowerUpState power_ups = 3;
  int power_ups_size() const;
  private:
  int _internal_power_ups_size() const;
  public:
  void clear_power_ups();
  ::rtype::PowerUpState* mutable_power_ups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::PowerUpState >*
      mutable_power_ups();
  private:
  const ::rtype::PowerUpState& _internal_power_ups(int index) const;
  ::rtype::PowerUpState* _internal_add_power_ups();
  public:
  const ::rtype::PowerUpState& power_ups(int index) const;
  ::rtype::PowerUpState* add_power_ups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::PowerUpState >&
      power_ups() const;

  // repeated .rtype.ScoreUpdate scores = 4;
  int scores_size() const;
  private:
  int _internal_scores_size() const;
  public:
  void clear_scores();
  ::rtype::ScoreUpdate* mutable_scores(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::ScoreUpdate >*
      mutable_scores();
  private:
  const ::rtype::ScoreUpdate& _internal_scores(int index) const;
  ::rtype::ScoreUpdate* _internal_add_scores();
  public:
  const ::rtype::ScoreUpdate& scores(int index) const;
  ::rtype::ScoreUpdate* add_scores();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::ScoreUpdate >&
      scores() const;

  // repeated .rtype.BulletState bullets = 6;
  int bullets_size() const;
  private:
  int _internal_bullets_size() const;
  public:
  void clear_bullets();
  ::rtype::BulletState* mutable_bullets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::BulletState >*
      mutable_bullets();
  private:
  const ::rtype::BulletState& _internal_bullets(int index) const;
  ::rtype::BulletState* _internal_add_bullets();
  public:
  const ::rtype::BulletState& bullets(int index) const;
  ::rtype::BulletState* add_bullets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::BulletState >&
      bullets() const;

  // .rtype.WaveInfo wave_info = 7;
  bool has_wave_info() const;
  private:
  bool _internal_has_wave_info() const;
  public:
  void clear_wave_info();
  const ::rtype::WaveInfo& wave_info() const;
  PROTOBUF_NODISCARD ::rtype::WaveInfo* release_wave_info();
  ::rtype::WaveInfo* mutable_wave_info();
  void set_allocated_wave_info(::rtype::WaveInfo* wave_info);
  private:
  const ::rtype::WaveInfo& _internal_wave_info() const;
  ::rtype::WaveInfo* _internal_mutable_wave_info();
  public:
  void unsafe_arena_set_allocated_wave_info(
      ::rtype::WaveInfo* wave_info);
  ::rtype::WaveInfo* unsafe_arena_release_wave_info();

  // uint64 timestamp = 5;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtype.GameState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::PlayerState > players_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::EnemyState > enemies_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::PowerUpState > power_ups_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::ScoreUpdate > scores_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::BulletState > bullets_;
  ::rtype::WaveInfo* wave_info_;
  uint64_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_r_5ftype_2eproto;
};
// -------------------------------------------------------------------

class Connect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtype.Connect) */ {
 public:
  inline Connect() : Connect(nullptr) {}
  ~Connect() override;
  explicit constexpr Connect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connect(const Connect& from);
  Connect(Connect&& from) noexcept
    : Connect() {
    *this = ::std::move(from);
  }

  inline Connect& operator=(const Connect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connect& operator=(Connect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connect* internal_default_instance() {
    return reinterpret_cast<const Connect*>(
               &_Connect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Connect& a, Connect& b) {
    a.Swap(&b);
  }
  inline void Swap(Connect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Connect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Connect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtype.Connect";
  }
  protected:
  explicit Connect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 1,
  };
  // string player_name = 1;
  void clear_player_name();
  const std::string& player_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_name();
  PROTOBUF_NODISCARD std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // @@protoc_insertion_point(class_scope:rtype.Connect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_r_5ftype_2eproto;
};
// -------------------------------------------------------------------

class ConnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtype.ConnectResponse) */ {
 public:
  inline ConnectResponse() : ConnectResponse(nullptr) {}
  ~ConnectResponse() override;
  explicit constexpr ConnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectResponse(const ConnectResponse& from);
  ConnectResponse(ConnectResponse&& from) noexcept
    : ConnectResponse() {
    *this = ::std::move(from);
  }

  inline ConnectResponse& operator=(const ConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectResponse& operator=(ConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectResponse* internal_default_instance() {
    return reinterpret_cast<const ConnectResponse*>(
               &_ConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ConnectResponse& a, ConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConnectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtype.ConnectResponse";
  }
  protected:
  explicit ConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // uint32 player_id = 1;
  void clear_player_id();
  uint32_t player_id() const;
  void set_player_id(uint32_t value);
  private:
  uint32_t _internal_player_id() const;
  void _internal_set_player_id(uint32_t value);
  public:

  // .rtype.ConnectResponseStatus status = 2;
  void clear_status();
  ::rtype::ConnectResponseStatus status() const;
  void set_status(::rtype::ConnectResponseStatus value);
  private:
  ::rtype::ConnectResponseStatus _internal_status() const;
  void _internal_set_status(::rtype::ConnectResponseStatus value);
  public:

  // @@protoc_insertion_point(class_scope:rtype.ConnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t player_id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_r_5ftype_2eproto;
};
// -------------------------------------------------------------------

class Payload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtype.Payload) */ {
 public:
  inline Payload() : Payload(nullptr) {}
  ~Payload() override;
  explicit constexpr Payload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Payload(const Payload& from);
  Payload(Payload&& from) noexcept
    : Payload() {
    *this = ::std::move(from);
  }

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payload& operator=(Payload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Payload& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadTypeCase {
    kConnect = 1,
    kConnectResponse = 2,
    kEvent = 3,
    kGameState = 4,
    PAYLOAD_TYPE_NOT_SET = 0,
  };

  static inline const Payload* internal_default_instance() {
    return reinterpret_cast<const Payload*>(
               &_Payload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Payload& a, Payload& b) {
    a.Swap(&b);
  }
  inline void Swap(Payload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Payload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Payload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Payload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Payload& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtype.Payload";
  }
  protected:
  explicit Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceNumberFieldNumber = 5,
    kConnectFieldNumber = 1,
    kConnectResponseFieldNumber = 2,
    kEventFieldNumber = 3,
    kGameStateFieldNumber = 4,
  };
  // uint32 sequence_number = 5;
  void clear_sequence_number();
  uint32_t sequence_number() const;
  void set_sequence_number(uint32_t value);
  private:
  uint32_t _internal_sequence_number() const;
  void _internal_set_sequence_number(uint32_t value);
  public:

  // .rtype.Connect connect = 1;
  bool has_connect() const;
  private:
  bool _internal_has_connect() const;
  public:
  void clear_connect();
  const ::rtype::Connect& connect() const;
  PROTOBUF_NODISCARD ::rtype::Connect* release_connect();
  ::rtype::Connect* mutable_connect();
  void set_allocated_connect(::rtype::Connect* connect);
  private:
  const ::rtype::Connect& _internal_connect() const;
  ::rtype::Connect* _internal_mutable_connect();
  public:
  void unsafe_arena_set_allocated_connect(
      ::rtype::Connect* connect);
  ::rtype::Connect* unsafe_arena_release_connect();

  // .rtype.ConnectResponse connect_response = 2;
  bool has_connect_response() const;
  private:
  bool _internal_has_connect_response() const;
  public:
  void clear_connect_response();
  const ::rtype::ConnectResponse& connect_response() const;
  PROTOBUF_NODISCARD ::rtype::ConnectResponse* release_connect_response();
  ::rtype::ConnectResponse* mutable_connect_response();
  void set_allocated_connect_response(::rtype::ConnectResponse* connect_response);
  private:
  const ::rtype::ConnectResponse& _internal_connect_response() const;
  ::rtype::ConnectResponse* _internal_mutable_connect_response();
  public:
  void unsafe_arena_set_allocated_connect_response(
      ::rtype::ConnectResponse* connect_response);
  ::rtype::ConnectResponse* unsafe_arena_release_connect_response();

  // .rtype.Event event = 3;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::rtype::Event& event() const;
  PROTOBUF_NODISCARD ::rtype::Event* release_event();
  ::rtype::Event* mutable_event();
  void set_allocated_event(::rtype::Event* event);
  private:
  const ::rtype::Event& _internal_event() const;
  ::rtype::Event* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::rtype::Event* event);
  ::rtype::Event* unsafe_arena_release_event();

  // .rtype.GameState game_state = 4;
  bool has_game_state() const;
  private:
  bool _internal_has_game_state() const;
  public:
  void clear_game_state();
  const ::rtype::GameState& game_state() const;
  PROTOBUF_NODISCARD ::rtype::GameState* release_game_state();
  ::rtype::GameState* mutable_game_state();
  void set_allocated_game_state(::rtype::GameState* game_state);
  private:
  const ::rtype::GameState& _internal_game_state() const;
  ::rtype::GameState* _internal_mutable_game_state();
  public:
  void unsafe_arena_set_allocated_game_state(
      ::rtype::GameState* game_state);
  ::rtype::GameState* unsafe_arena_release_game_state();

  void clear_payload_type();
  PayloadTypeCase payload_type_case() const;
  // @@protoc_insertion_point(class_scope:rtype.Payload)
 private:
  class _Internal;
  void set_has_connect();
  void set_has_connect_response();
  void set_has_event();
  void set_has_game_state();

  inline bool has_payload_type() const;
  inline void clear_has_payload_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t sequence_number_;
  union PayloadTypeUnion {
    constexpr PayloadTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::rtype::Connect* connect_;
    ::rtype::ConnectResponse* connect_response_;
    ::rtype::Event* event_;
    ::rtype::GameState* game_state_;
  } payload_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_r_5ftype_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Event

// .rtype.EventType event = 1;
inline void Event::clear_event() {
  event_ = 0;
}
inline ::rtype::EventType Event::_internal_event() const {
  return static_cast< ::rtype::EventType >(event_);
}
inline ::rtype::EventType Event::event() const {
  // @@protoc_insertion_point(field_get:rtype.Event.event)
  return _internal_event();
}
inline void Event::_internal_set_event(::rtype::EventType value) {
  
  event_ = value;
}
inline void Event::set_event(::rtype::EventType value) {
  _internal_set_event(value);
  // @@protoc_insertion_point(field_set:rtype.Event.event)
}

// -------------------------------------------------------------------

// PlayerState

// uint32 player_id = 1;
inline void PlayerState::clear_player_id() {
  player_id_ = 0u;
}
inline uint32_t PlayerState::_internal_player_id() const {
  return player_id_;
}
inline uint32_t PlayerState::player_id() const {
  // @@protoc_insertion_point(field_get:rtype.PlayerState.player_id)
  return _internal_player_id();
}
inline void PlayerState::_internal_set_player_id(uint32_t value) {
  
  player_id_ = value;
}
inline void PlayerState::set_player_id(uint32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:rtype.PlayerState.player_id)
}

// float pos_x = 2;
inline void PlayerState::clear_pos_x() {
  pos_x_ = 0;
}
inline float PlayerState::_internal_pos_x() const {
  return pos_x_;
}
inline float PlayerState::pos_x() const {
  // @@protoc_insertion_point(field_get:rtype.PlayerState.pos_x)
  return _internal_pos_x();
}
inline void PlayerState::_internal_set_pos_x(float value) {
  
  pos_x_ = value;
}
inline void PlayerState::set_pos_x(float value) {
  _internal_set_pos_x(value);
  // @@protoc_insertion_point(field_set:rtype.PlayerState.pos_x)
}

// float pos_y = 3;
inline void PlayerState::clear_pos_y() {
  pos_y_ = 0;
}
inline float PlayerState::_internal_pos_y() const {
  return pos_y_;
}
inline float PlayerState::pos_y() const {
  // @@protoc_insertion_point(field_get:rtype.PlayerState.pos_y)
  return _internal_pos_y();
}
inline void PlayerState::_internal_set_pos_y(float value) {
  
  pos_y_ = value;
}
inline void PlayerState::set_pos_y(float value) {
  _internal_set_pos_y(value);
  // @@protoc_insertion_point(field_set:rtype.PlayerState.pos_y)
}

// float health = 5;
inline void PlayerState::clear_health() {
  health_ = 0;
}
inline float PlayerState::_internal_health() const {
  return health_;
}
inline float PlayerState::health() const {
  // @@protoc_insertion_point(field_get:rtype.PlayerState.health)
  return _internal_health();
}
inline void PlayerState::_internal_set_health(float value) {
  
  health_ = value;
}
inline void PlayerState::set_health(float value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:rtype.PlayerState.health)
}

// bool is_shooting = 6;
inline void PlayerState::clear_is_shooting() {
  is_shooting_ = false;
}
inline bool PlayerState::_internal_is_shooting() const {
  return is_shooting_;
}
inline bool PlayerState::is_shooting() const {
  // @@protoc_insertion_point(field_get:rtype.PlayerState.is_shooting)
  return _internal_is_shooting();
}
inline void PlayerState::_internal_set_is_shooting(bool value) {
  
  is_shooting_ = value;
}
inline void PlayerState::set_is_shooting(bool value) {
  _internal_set_is_shooting(value);
  // @@protoc_insertion_point(field_set:rtype.PlayerState.is_shooting)
}

// -------------------------------------------------------------------

// EnemyState

// uint32 enemy_id = 1;
inline void EnemyState::clear_enemy_id() {
  enemy_id_ = 0u;
}
inline uint32_t EnemyState::_internal_enemy_id() const {
  return enemy_id_;
}
inline uint32_t EnemyState::enemy_id() const {
  // @@protoc_insertion_point(field_get:rtype.EnemyState.enemy_id)
  return _internal_enemy_id();
}
inline void EnemyState::_internal_set_enemy_id(uint32_t value) {
  
  enemy_id_ = value;
}
inline void EnemyState::set_enemy_id(uint32_t value) {
  _internal_set_enemy_id(value);
  // @@protoc_insertion_point(field_set:rtype.EnemyState.enemy_id)
}

// float pos_x = 2;
inline void EnemyState::clear_pos_x() {
  pos_x_ = 0;
}
inline float EnemyState::_internal_pos_x() const {
  return pos_x_;
}
inline float EnemyState::pos_x() const {
  // @@protoc_insertion_point(field_get:rtype.EnemyState.pos_x)
  return _internal_pos_x();
}
inline void EnemyState::_internal_set_pos_x(float value) {
  
  pos_x_ = value;
}
inline void EnemyState::set_pos_x(float value) {
  _internal_set_pos_x(value);
  // @@protoc_insertion_point(field_set:rtype.EnemyState.pos_x)
}

// float pos_y = 3;
inline void EnemyState::clear_pos_y() {
  pos_y_ = 0;
}
inline float EnemyState::_internal_pos_y() const {
  return pos_y_;
}
inline float EnemyState::pos_y() const {
  // @@protoc_insertion_point(field_get:rtype.EnemyState.pos_y)
  return _internal_pos_y();
}
inline void EnemyState::_internal_set_pos_y(float value) {
  
  pos_y_ = value;
}
inline void EnemyState::set_pos_y(float value) {
  _internal_set_pos_y(value);
  // @@protoc_insertion_point(field_set:rtype.EnemyState.pos_y)
}

// string type = 4;
inline void EnemyState::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& EnemyState::type() const {
  // @@protoc_insertion_point(field_get:rtype.EnemyState.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnemyState::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtype.EnemyState.type)
}
inline std::string* EnemyState::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:rtype.EnemyState.type)
  return _s;
}
inline const std::string& EnemyState::_internal_type() const {
  return type_.Get();
}
inline void EnemyState::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnemyState::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnemyState::release_type() {
  // @@protoc_insertion_point(field_release:rtype.EnemyState.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnemyState::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtype.EnemyState.type)
}

// float health = 5;
inline void EnemyState::clear_health() {
  health_ = 0;
}
inline float EnemyState::_internal_health() const {
  return health_;
}
inline float EnemyState::health() const {
  // @@protoc_insertion_point(field_get:rtype.EnemyState.health)
  return _internal_health();
}
inline void EnemyState::_internal_set_health(float value) {
  
  health_ = value;
}
inline void EnemyState::set_health(float value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:rtype.EnemyState.health)
}

// -------------------------------------------------------------------

// PowerUpState

// uint32 power_up_id = 1;
inline void PowerUpState::clear_power_up_id() {
  power_up_id_ = 0u;
}
inline uint32_t PowerUpState::_internal_power_up_id() const {
  return power_up_id_;
}
inline uint32_t PowerUpState::power_up_id() const {
  // @@protoc_insertion_point(field_get:rtype.PowerUpState.power_up_id)
  return _internal_power_up_id();
}
inline void PowerUpState::_internal_set_power_up_id(uint32_t value) {
  
  power_up_id_ = value;
}
inline void PowerUpState::set_power_up_id(uint32_t value) {
  _internal_set_power_up_id(value);
  // @@protoc_insertion_point(field_set:rtype.PowerUpState.power_up_id)
}

// float pos_x = 2;
inline void PowerUpState::clear_pos_x() {
  pos_x_ = 0;
}
inline float PowerUpState::_internal_pos_x() const {
  return pos_x_;
}
inline float PowerUpState::pos_x() const {
  // @@protoc_insertion_point(field_get:rtype.PowerUpState.pos_x)
  return _internal_pos_x();
}
inline void PowerUpState::_internal_set_pos_x(float value) {
  
  pos_x_ = value;
}
inline void PowerUpState::set_pos_x(float value) {
  _internal_set_pos_x(value);
  // @@protoc_insertion_point(field_set:rtype.PowerUpState.pos_x)
}

// float pos_y = 3;
inline void PowerUpState::clear_pos_y() {
  pos_y_ = 0;
}
inline float PowerUpState::_internal_pos_y() const {
  return pos_y_;
}
inline float PowerUpState::pos_y() const {
  // @@protoc_insertion_point(field_get:rtype.PowerUpState.pos_y)
  return _internal_pos_y();
}
inline void PowerUpState::_internal_set_pos_y(float value) {
  
  pos_y_ = value;
}
inline void PowerUpState::set_pos_y(float value) {
  _internal_set_pos_y(value);
  // @@protoc_insertion_point(field_set:rtype.PowerUpState.pos_y)
}

// string type = 4;
inline void PowerUpState::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& PowerUpState::type() const {
  // @@protoc_insertion_point(field_get:rtype.PowerUpState.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PowerUpState::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtype.PowerUpState.type)
}
inline std::string* PowerUpState::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:rtype.PowerUpState.type)
  return _s;
}
inline const std::string& PowerUpState::_internal_type() const {
  return type_.Get();
}
inline void PowerUpState::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PowerUpState::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PowerUpState::release_type() {
  // @@protoc_insertion_point(field_release:rtype.PowerUpState.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PowerUpState::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtype.PowerUpState.type)
}

// -------------------------------------------------------------------

// ScoreUpdate

// uint32 player_id = 1;
inline void ScoreUpdate::clear_player_id() {
  player_id_ = 0u;
}
inline uint32_t ScoreUpdate::_internal_player_id() const {
  return player_id_;
}
inline uint32_t ScoreUpdate::player_id() const {
  // @@protoc_insertion_point(field_get:rtype.ScoreUpdate.player_id)
  return _internal_player_id();
}
inline void ScoreUpdate::_internal_set_player_id(uint32_t value) {
  
  player_id_ = value;
}
inline void ScoreUpdate::set_player_id(uint32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:rtype.ScoreUpdate.player_id)
}

// int32 score = 2;
inline void ScoreUpdate::clear_score() {
  score_ = 0;
}
inline int32_t ScoreUpdate::_internal_score() const {
  return score_;
}
inline int32_t ScoreUpdate::score() const {
  // @@protoc_insertion_point(field_get:rtype.ScoreUpdate.score)
  return _internal_score();
}
inline void ScoreUpdate::_internal_set_score(int32_t value) {
  
  score_ = value;
}
inline void ScoreUpdate::set_score(int32_t value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:rtype.ScoreUpdate.score)
}

// -------------------------------------------------------------------

// WaveInfo

// int32 current_wave = 1;
inline void WaveInfo::clear_current_wave() {
  current_wave_ = 0;
}
inline int32_t WaveInfo::_internal_current_wave() const {
  return current_wave_;
}
inline int32_t WaveInfo::current_wave() const {
  // @@protoc_insertion_point(field_get:rtype.WaveInfo.current_wave)
  return _internal_current_wave();
}
inline void WaveInfo::_internal_set_current_wave(int32_t value) {
  
  current_wave_ = value;
}
inline void WaveInfo::set_current_wave(int32_t value) {
  _internal_set_current_wave(value);
  // @@protoc_insertion_point(field_set:rtype.WaveInfo.current_wave)
}

// int32 total_enemies = 2;
inline void WaveInfo::clear_total_enemies() {
  total_enemies_ = 0;
}
inline int32_t WaveInfo::_internal_total_enemies() const {
  return total_enemies_;
}
inline int32_t WaveInfo::total_enemies() const {
  // @@protoc_insertion_point(field_get:rtype.WaveInfo.total_enemies)
  return _internal_total_enemies();
}
inline void WaveInfo::_internal_set_total_enemies(int32_t value) {
  
  total_enemies_ = value;
}
inline void WaveInfo::set_total_enemies(int32_t value) {
  _internal_set_total_enemies(value);
  // @@protoc_insertion_point(field_set:rtype.WaveInfo.total_enemies)
}

// bool wave_in_progress = 3;
inline void WaveInfo::clear_wave_in_progress() {
  wave_in_progress_ = false;
}
inline bool WaveInfo::_internal_wave_in_progress() const {
  return wave_in_progress_;
}
inline bool WaveInfo::wave_in_progress() const {
  // @@protoc_insertion_point(field_get:rtype.WaveInfo.wave_in_progress)
  return _internal_wave_in_progress();
}
inline void WaveInfo::_internal_set_wave_in_progress(bool value) {
  
  wave_in_progress_ = value;
}
inline void WaveInfo::set_wave_in_progress(bool value) {
  _internal_set_wave_in_progress(value);
  // @@protoc_insertion_point(field_set:rtype.WaveInfo.wave_in_progress)
}

// -------------------------------------------------------------------

// BulletState

// uint32 bullet_id = 1;
inline void BulletState::clear_bullet_id() {
  bullet_id_ = 0u;
}
inline uint32_t BulletState::_internal_bullet_id() const {
  return bullet_id_;
}
inline uint32_t BulletState::bullet_id() const {
  // @@protoc_insertion_point(field_get:rtype.BulletState.bullet_id)
  return _internal_bullet_id();
}
inline void BulletState::_internal_set_bullet_id(uint32_t value) {
  
  bullet_id_ = value;
}
inline void BulletState::set_bullet_id(uint32_t value) {
  _internal_set_bullet_id(value);
  // @@protoc_insertion_point(field_set:rtype.BulletState.bullet_id)
}

// float pos_x = 2;
inline void BulletState::clear_pos_x() {
  pos_x_ = 0;
}
inline float BulletState::_internal_pos_x() const {
  return pos_x_;
}
inline float BulletState::pos_x() const {
  // @@protoc_insertion_point(field_get:rtype.BulletState.pos_x)
  return _internal_pos_x();
}
inline void BulletState::_internal_set_pos_x(float value) {
  
  pos_x_ = value;
}
inline void BulletState::set_pos_x(float value) {
  _internal_set_pos_x(value);
  // @@protoc_insertion_point(field_set:rtype.BulletState.pos_x)
}

// float pos_y = 3;
inline void BulletState::clear_pos_y() {
  pos_y_ = 0;
}
inline float BulletState::_internal_pos_y() const {
  return pos_y_;
}
inline float BulletState::pos_y() const {
  // @@protoc_insertion_point(field_get:rtype.BulletState.pos_y)
  return _internal_pos_y();
}
inline void BulletState::_internal_set_pos_y(float value) {
  
  pos_y_ = value;
}
inline void BulletState::set_pos_y(float value) {
  _internal_set_pos_y(value);
  // @@protoc_insertion_point(field_set:rtype.BulletState.pos_y)
}

// float direction_x = 4;
inline void BulletState::clear_direction_x() {
  direction_x_ = 0;
}
inline float BulletState::_internal_direction_x() const {
  return direction_x_;
}
inline float BulletState::direction_x() const {
  // @@protoc_insertion_point(field_get:rtype.BulletState.direction_x)
  return _internal_direction_x();
}
inline void BulletState::_internal_set_direction_x(float value) {
  
  direction_x_ = value;
}
inline void BulletState::set_direction_x(float value) {
  _internal_set_direction_x(value);
  // @@protoc_insertion_point(field_set:rtype.BulletState.direction_x)
}

// float direction_y = 5;
inline void BulletState::clear_direction_y() {
  direction_y_ = 0;
}
inline float BulletState::_internal_direction_y() const {
  return direction_y_;
}
inline float BulletState::direction_y() const {
  // @@protoc_insertion_point(field_get:rtype.BulletState.direction_y)
  return _internal_direction_y();
}
inline void BulletState::_internal_set_direction_y(float value) {
  
  direction_y_ = value;
}
inline void BulletState::set_direction_y(float value) {
  _internal_set_direction_y(value);
  // @@protoc_insertion_point(field_set:rtype.BulletState.direction_y)
}

// float speed = 6;
inline void BulletState::clear_speed() {
  speed_ = 0;
}
inline float BulletState::_internal_speed() const {
  return speed_;
}
inline float BulletState::speed() const {
  // @@protoc_insertion_point(field_get:rtype.BulletState.speed)
  return _internal_speed();
}
inline void BulletState::_internal_set_speed(float value) {
  
  speed_ = value;
}
inline void BulletState::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:rtype.BulletState.speed)
}

// uint32 owner_id = 7;
inline void BulletState::clear_owner_id() {
  owner_id_ = 0u;
}
inline uint32_t BulletState::_internal_owner_id() const {
  return owner_id_;
}
inline uint32_t BulletState::owner_id() const {
  // @@protoc_insertion_point(field_get:rtype.BulletState.owner_id)
  return _internal_owner_id();
}
inline void BulletState::_internal_set_owner_id(uint32_t value) {
  
  owner_id_ = value;
}
inline void BulletState::set_owner_id(uint32_t value) {
  _internal_set_owner_id(value);
  // @@protoc_insertion_point(field_set:rtype.BulletState.owner_id)
}

// -------------------------------------------------------------------

// GameState

// repeated .rtype.PlayerState players = 1;
inline int GameState::_internal_players_size() const {
  return players_.size();
}
inline int GameState::players_size() const {
  return _internal_players_size();
}
inline void GameState::clear_players() {
  players_.Clear();
}
inline ::rtype::PlayerState* GameState::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:rtype.GameState.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::PlayerState >*
GameState::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:rtype.GameState.players)
  return &players_;
}
inline const ::rtype::PlayerState& GameState::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::rtype::PlayerState& GameState::players(int index) const {
  // @@protoc_insertion_point(field_get:rtype.GameState.players)
  return _internal_players(index);
}
inline ::rtype::PlayerState* GameState::_internal_add_players() {
  return players_.Add();
}
inline ::rtype::PlayerState* GameState::add_players() {
  ::rtype::PlayerState* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:rtype.GameState.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::PlayerState >&
GameState::players() const {
  // @@protoc_insertion_point(field_list:rtype.GameState.players)
  return players_;
}

// repeated .rtype.EnemyState enemies = 2;
inline int GameState::_internal_enemies_size() const {
  return enemies_.size();
}
inline int GameState::enemies_size() const {
  return _internal_enemies_size();
}
inline void GameState::clear_enemies() {
  enemies_.Clear();
}
inline ::rtype::EnemyState* GameState::mutable_enemies(int index) {
  // @@protoc_insertion_point(field_mutable:rtype.GameState.enemies)
  return enemies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::EnemyState >*
GameState::mutable_enemies() {
  // @@protoc_insertion_point(field_mutable_list:rtype.GameState.enemies)
  return &enemies_;
}
inline const ::rtype::EnemyState& GameState::_internal_enemies(int index) const {
  return enemies_.Get(index);
}
inline const ::rtype::EnemyState& GameState::enemies(int index) const {
  // @@protoc_insertion_point(field_get:rtype.GameState.enemies)
  return _internal_enemies(index);
}
inline ::rtype::EnemyState* GameState::_internal_add_enemies() {
  return enemies_.Add();
}
inline ::rtype::EnemyState* GameState::add_enemies() {
  ::rtype::EnemyState* _add = _internal_add_enemies();
  // @@protoc_insertion_point(field_add:rtype.GameState.enemies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::EnemyState >&
GameState::enemies() const {
  // @@protoc_insertion_point(field_list:rtype.GameState.enemies)
  return enemies_;
}

// repeated .rtype.PowerUpState power_ups = 3;
inline int GameState::_internal_power_ups_size() const {
  return power_ups_.size();
}
inline int GameState::power_ups_size() const {
  return _internal_power_ups_size();
}
inline void GameState::clear_power_ups() {
  power_ups_.Clear();
}
inline ::rtype::PowerUpState* GameState::mutable_power_ups(int index) {
  // @@protoc_insertion_point(field_mutable:rtype.GameState.power_ups)
  return power_ups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::PowerUpState >*
GameState::mutable_power_ups() {
  // @@protoc_insertion_point(field_mutable_list:rtype.GameState.power_ups)
  return &power_ups_;
}
inline const ::rtype::PowerUpState& GameState::_internal_power_ups(int index) const {
  return power_ups_.Get(index);
}
inline const ::rtype::PowerUpState& GameState::power_ups(int index) const {
  // @@protoc_insertion_point(field_get:rtype.GameState.power_ups)
  return _internal_power_ups(index);
}
inline ::rtype::PowerUpState* GameState::_internal_add_power_ups() {
  return power_ups_.Add();
}
inline ::rtype::PowerUpState* GameState::add_power_ups() {
  ::rtype::PowerUpState* _add = _internal_add_power_ups();
  // @@protoc_insertion_point(field_add:rtype.GameState.power_ups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::PowerUpState >&
GameState::power_ups() const {
  // @@protoc_insertion_point(field_list:rtype.GameState.power_ups)
  return power_ups_;
}

// repeated .rtype.ScoreUpdate scores = 4;
inline int GameState::_internal_scores_size() const {
  return scores_.size();
}
inline int GameState::scores_size() const {
  return _internal_scores_size();
}
inline void GameState::clear_scores() {
  scores_.Clear();
}
inline ::rtype::ScoreUpdate* GameState::mutable_scores(int index) {
  // @@protoc_insertion_point(field_mutable:rtype.GameState.scores)
  return scores_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::ScoreUpdate >*
GameState::mutable_scores() {
  // @@protoc_insertion_point(field_mutable_list:rtype.GameState.scores)
  return &scores_;
}
inline const ::rtype::ScoreUpdate& GameState::_internal_scores(int index) const {
  return scores_.Get(index);
}
inline const ::rtype::ScoreUpdate& GameState::scores(int index) const {
  // @@protoc_insertion_point(field_get:rtype.GameState.scores)
  return _internal_scores(index);
}
inline ::rtype::ScoreUpdate* GameState::_internal_add_scores() {
  return scores_.Add();
}
inline ::rtype::ScoreUpdate* GameState::add_scores() {
  ::rtype::ScoreUpdate* _add = _internal_add_scores();
  // @@protoc_insertion_point(field_add:rtype.GameState.scores)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::ScoreUpdate >&
GameState::scores() const {
  // @@protoc_insertion_point(field_list:rtype.GameState.scores)
  return scores_;
}

// repeated .rtype.BulletState bullets = 6;
inline int GameState::_internal_bullets_size() const {
  return bullets_.size();
}
inline int GameState::bullets_size() const {
  return _internal_bullets_size();
}
inline void GameState::clear_bullets() {
  bullets_.Clear();
}
inline ::rtype::BulletState* GameState::mutable_bullets(int index) {
  // @@protoc_insertion_point(field_mutable:rtype.GameState.bullets)
  return bullets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::BulletState >*
GameState::mutable_bullets() {
  // @@protoc_insertion_point(field_mutable_list:rtype.GameState.bullets)
  return &bullets_;
}
inline const ::rtype::BulletState& GameState::_internal_bullets(int index) const {
  return bullets_.Get(index);
}
inline const ::rtype::BulletState& GameState::bullets(int index) const {
  // @@protoc_insertion_point(field_get:rtype.GameState.bullets)
  return _internal_bullets(index);
}
inline ::rtype::BulletState* GameState::_internal_add_bullets() {
  return bullets_.Add();
}
inline ::rtype::BulletState* GameState::add_bullets() {
  ::rtype::BulletState* _add = _internal_add_bullets();
  // @@protoc_insertion_point(field_add:rtype.GameState.bullets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtype::BulletState >&
GameState::bullets() const {
  // @@protoc_insertion_point(field_list:rtype.GameState.bullets)
  return bullets_;
}

// .rtype.WaveInfo wave_info = 7;
inline bool GameState::_internal_has_wave_info() const {
  return this != internal_default_instance() && wave_info_ != nullptr;
}
inline bool GameState::has_wave_info() const {
  return _internal_has_wave_info();
}
inline void GameState::clear_wave_info() {
  if (GetArenaForAllocation() == nullptr && wave_info_ != nullptr) {
    delete wave_info_;
  }
  wave_info_ = nullptr;
}
inline const ::rtype::WaveInfo& GameState::_internal_wave_info() const {
  const ::rtype::WaveInfo* p = wave_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtype::WaveInfo&>(
      ::rtype::_WaveInfo_default_instance_);
}
inline const ::rtype::WaveInfo& GameState::wave_info() const {
  // @@protoc_insertion_point(field_get:rtype.GameState.wave_info)
  return _internal_wave_info();
}
inline void GameState::unsafe_arena_set_allocated_wave_info(
    ::rtype::WaveInfo* wave_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wave_info_);
  }
  wave_info_ = wave_info;
  if (wave_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtype.GameState.wave_info)
}
inline ::rtype::WaveInfo* GameState::release_wave_info() {
  
  ::rtype::WaveInfo* temp = wave_info_;
  wave_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtype::WaveInfo* GameState::unsafe_arena_release_wave_info() {
  // @@protoc_insertion_point(field_release:rtype.GameState.wave_info)
  
  ::rtype::WaveInfo* temp = wave_info_;
  wave_info_ = nullptr;
  return temp;
}
inline ::rtype::WaveInfo* GameState::_internal_mutable_wave_info() {
  
  if (wave_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtype::WaveInfo>(GetArenaForAllocation());
    wave_info_ = p;
  }
  return wave_info_;
}
inline ::rtype::WaveInfo* GameState::mutable_wave_info() {
  ::rtype::WaveInfo* _msg = _internal_mutable_wave_info();
  // @@protoc_insertion_point(field_mutable:rtype.GameState.wave_info)
  return _msg;
}
inline void GameState::set_allocated_wave_info(::rtype::WaveInfo* wave_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete wave_info_;
  }
  if (wave_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rtype::WaveInfo>::GetOwningArena(wave_info);
    if (message_arena != submessage_arena) {
      wave_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wave_info, submessage_arena);
    }
    
  } else {
    
  }
  wave_info_ = wave_info;
  // @@protoc_insertion_point(field_set_allocated:rtype.GameState.wave_info)
}

// uint64 timestamp = 5;
inline void GameState::clear_timestamp() {
  timestamp_ = uint64_t{0u};
}
inline uint64_t GameState::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t GameState::timestamp() const {
  // @@protoc_insertion_point(field_get:rtype.GameState.timestamp)
  return _internal_timestamp();
}
inline void GameState::_internal_set_timestamp(uint64_t value) {
  
  timestamp_ = value;
}
inline void GameState::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtype.GameState.timestamp)
}

// -------------------------------------------------------------------

// Connect

// string player_name = 1;
inline void Connect::clear_player_name() {
  player_name_.ClearToEmpty();
}
inline const std::string& Connect::player_name() const {
  // @@protoc_insertion_point(field_get:rtype.Connect.player_name)
  return _internal_player_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connect::set_player_name(ArgT0&& arg0, ArgT... args) {
 
 player_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtype.Connect.player_name)
}
inline std::string* Connect::mutable_player_name() {
  std::string* _s = _internal_mutable_player_name();
  // @@protoc_insertion_point(field_mutable:rtype.Connect.player_name)
  return _s;
}
inline const std::string& Connect::_internal_player_name() const {
  return player_name_.Get();
}
inline void Connect::_internal_set_player_name(const std::string& value) {
  
  player_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Connect::_internal_mutable_player_name() {
  
  return player_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Connect::release_player_name() {
  // @@protoc_insertion_point(field_release:rtype.Connect.player_name)
  return player_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Connect::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    
  } else {
    
  }
  player_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), player_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (player_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    player_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtype.Connect.player_name)
}

// -------------------------------------------------------------------

// ConnectResponse

// uint32 player_id = 1;
inline void ConnectResponse::clear_player_id() {
  player_id_ = 0u;
}
inline uint32_t ConnectResponse::_internal_player_id() const {
  return player_id_;
}
inline uint32_t ConnectResponse::player_id() const {
  // @@protoc_insertion_point(field_get:rtype.ConnectResponse.player_id)
  return _internal_player_id();
}
inline void ConnectResponse::_internal_set_player_id(uint32_t value) {
  
  player_id_ = value;
}
inline void ConnectResponse::set_player_id(uint32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:rtype.ConnectResponse.player_id)
}

// .rtype.ConnectResponseStatus status = 2;
inline void ConnectResponse::clear_status() {
  status_ = 0;
}
inline ::rtype::ConnectResponseStatus ConnectResponse::_internal_status() const {
  return static_cast< ::rtype::ConnectResponseStatus >(status_);
}
inline ::rtype::ConnectResponseStatus ConnectResponse::status() const {
  // @@protoc_insertion_point(field_get:rtype.ConnectResponse.status)
  return _internal_status();
}
inline void ConnectResponse::_internal_set_status(::rtype::ConnectResponseStatus value) {
  
  status_ = value;
}
inline void ConnectResponse::set_status(::rtype::ConnectResponseStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:rtype.ConnectResponse.status)
}

// -------------------------------------------------------------------

// Payload

// .rtype.Connect connect = 1;
inline bool Payload::_internal_has_connect() const {
  return payload_type_case() == kConnect;
}
inline bool Payload::has_connect() const {
  return _internal_has_connect();
}
inline void Payload::set_has_connect() {
  _oneof_case_[0] = kConnect;
}
inline void Payload::clear_connect() {
  if (_internal_has_connect()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_type_.connect_;
    }
    clear_has_payload_type();
  }
}
inline ::rtype::Connect* Payload::release_connect() {
  // @@protoc_insertion_point(field_release:rtype.Payload.connect)
  if (_internal_has_connect()) {
    clear_has_payload_type();
      ::rtype::Connect* temp = payload_type_.connect_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_type_.connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtype::Connect& Payload::_internal_connect() const {
  return _internal_has_connect()
      ? *payload_type_.connect_
      : reinterpret_cast< ::rtype::Connect&>(::rtype::_Connect_default_instance_);
}
inline const ::rtype::Connect& Payload::connect() const {
  // @@protoc_insertion_point(field_get:rtype.Payload.connect)
  return _internal_connect();
}
inline ::rtype::Connect* Payload::unsafe_arena_release_connect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtype.Payload.connect)
  if (_internal_has_connect()) {
    clear_has_payload_type();
    ::rtype::Connect* temp = payload_type_.connect_;
    payload_type_.connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Payload::unsafe_arena_set_allocated_connect(::rtype::Connect* connect) {
  clear_payload_type();
  if (connect) {
    set_has_connect();
    payload_type_.connect_ = connect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtype.Payload.connect)
}
inline ::rtype::Connect* Payload::_internal_mutable_connect() {
  if (!_internal_has_connect()) {
    clear_payload_type();
    set_has_connect();
    payload_type_.connect_ = CreateMaybeMessage< ::rtype::Connect >(GetArenaForAllocation());
  }
  return payload_type_.connect_;
}
inline ::rtype::Connect* Payload::mutable_connect() {
  ::rtype::Connect* _msg = _internal_mutable_connect();
  // @@protoc_insertion_point(field_mutable:rtype.Payload.connect)
  return _msg;
}

// .rtype.ConnectResponse connect_response = 2;
inline bool Payload::_internal_has_connect_response() const {
  return payload_type_case() == kConnectResponse;
}
inline bool Payload::has_connect_response() const {
  return _internal_has_connect_response();
}
inline void Payload::set_has_connect_response() {
  _oneof_case_[0] = kConnectResponse;
}
inline void Payload::clear_connect_response() {
  if (_internal_has_connect_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_type_.connect_response_;
    }
    clear_has_payload_type();
  }
}
inline ::rtype::ConnectResponse* Payload::release_connect_response() {
  // @@protoc_insertion_point(field_release:rtype.Payload.connect_response)
  if (_internal_has_connect_response()) {
    clear_has_payload_type();
      ::rtype::ConnectResponse* temp = payload_type_.connect_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_type_.connect_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtype::ConnectResponse& Payload::_internal_connect_response() const {
  return _internal_has_connect_response()
      ? *payload_type_.connect_response_
      : reinterpret_cast< ::rtype::ConnectResponse&>(::rtype::_ConnectResponse_default_instance_);
}
inline const ::rtype::ConnectResponse& Payload::connect_response() const {
  // @@protoc_insertion_point(field_get:rtype.Payload.connect_response)
  return _internal_connect_response();
}
inline ::rtype::ConnectResponse* Payload::unsafe_arena_release_connect_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtype.Payload.connect_response)
  if (_internal_has_connect_response()) {
    clear_has_payload_type();
    ::rtype::ConnectResponse* temp = payload_type_.connect_response_;
    payload_type_.connect_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Payload::unsafe_arena_set_allocated_connect_response(::rtype::ConnectResponse* connect_response) {
  clear_payload_type();
  if (connect_response) {
    set_has_connect_response();
    payload_type_.connect_response_ = connect_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtype.Payload.connect_response)
}
inline ::rtype::ConnectResponse* Payload::_internal_mutable_connect_response() {
  if (!_internal_has_connect_response()) {
    clear_payload_type();
    set_has_connect_response();
    payload_type_.connect_response_ = CreateMaybeMessage< ::rtype::ConnectResponse >(GetArenaForAllocation());
  }
  return payload_type_.connect_response_;
}
inline ::rtype::ConnectResponse* Payload::mutable_connect_response() {
  ::rtype::ConnectResponse* _msg = _internal_mutable_connect_response();
  // @@protoc_insertion_point(field_mutable:rtype.Payload.connect_response)
  return _msg;
}

// .rtype.Event event = 3;
inline bool Payload::_internal_has_event() const {
  return payload_type_case() == kEvent;
}
inline bool Payload::has_event() const {
  return _internal_has_event();
}
inline void Payload::set_has_event() {
  _oneof_case_[0] = kEvent;
}
inline void Payload::clear_event() {
  if (_internal_has_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_type_.event_;
    }
    clear_has_payload_type();
  }
}
inline ::rtype::Event* Payload::release_event() {
  // @@protoc_insertion_point(field_release:rtype.Payload.event)
  if (_internal_has_event()) {
    clear_has_payload_type();
      ::rtype::Event* temp = payload_type_.event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_type_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtype::Event& Payload::_internal_event() const {
  return _internal_has_event()
      ? *payload_type_.event_
      : reinterpret_cast< ::rtype::Event&>(::rtype::_Event_default_instance_);
}
inline const ::rtype::Event& Payload::event() const {
  // @@protoc_insertion_point(field_get:rtype.Payload.event)
  return _internal_event();
}
inline ::rtype::Event* Payload::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtype.Payload.event)
  if (_internal_has_event()) {
    clear_has_payload_type();
    ::rtype::Event* temp = payload_type_.event_;
    payload_type_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Payload::unsafe_arena_set_allocated_event(::rtype::Event* event) {
  clear_payload_type();
  if (event) {
    set_has_event();
    payload_type_.event_ = event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtype.Payload.event)
}
inline ::rtype::Event* Payload::_internal_mutable_event() {
  if (!_internal_has_event()) {
    clear_payload_type();
    set_has_event();
    payload_type_.event_ = CreateMaybeMessage< ::rtype::Event >(GetArenaForAllocation());
  }
  return payload_type_.event_;
}
inline ::rtype::Event* Payload::mutable_event() {
  ::rtype::Event* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:rtype.Payload.event)
  return _msg;
}

// .rtype.GameState game_state = 4;
inline bool Payload::_internal_has_game_state() const {
  return payload_type_case() == kGameState;
}
inline bool Payload::has_game_state() const {
  return _internal_has_game_state();
}
inline void Payload::set_has_game_state() {
  _oneof_case_[0] = kGameState;
}
inline void Payload::clear_game_state() {
  if (_internal_has_game_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_type_.game_state_;
    }
    clear_has_payload_type();
  }
}
inline ::rtype::GameState* Payload::release_game_state() {
  // @@protoc_insertion_point(field_release:rtype.Payload.game_state)
  if (_internal_has_game_state()) {
    clear_has_payload_type();
      ::rtype::GameState* temp = payload_type_.game_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_type_.game_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtype::GameState& Payload::_internal_game_state() const {
  return _internal_has_game_state()
      ? *payload_type_.game_state_
      : reinterpret_cast< ::rtype::GameState&>(::rtype::_GameState_default_instance_);
}
inline const ::rtype::GameState& Payload::game_state() const {
  // @@protoc_insertion_point(field_get:rtype.Payload.game_state)
  return _internal_game_state();
}
inline ::rtype::GameState* Payload::unsafe_arena_release_game_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtype.Payload.game_state)
  if (_internal_has_game_state()) {
    clear_has_payload_type();
    ::rtype::GameState* temp = payload_type_.game_state_;
    payload_type_.game_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Payload::unsafe_arena_set_allocated_game_state(::rtype::GameState* game_state) {
  clear_payload_type();
  if (game_state) {
    set_has_game_state();
    payload_type_.game_state_ = game_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtype.Payload.game_state)
}
inline ::rtype::GameState* Payload::_internal_mutable_game_state() {
  if (!_internal_has_game_state()) {
    clear_payload_type();
    set_has_game_state();
    payload_type_.game_state_ = CreateMaybeMessage< ::rtype::GameState >(GetArenaForAllocation());
  }
  return payload_type_.game_state_;
}
inline ::rtype::GameState* Payload::mutable_game_state() {
  ::rtype::GameState* _msg = _internal_mutable_game_state();
  // @@protoc_insertion_point(field_mutable:rtype.Payload.game_state)
  return _msg;
}

// uint32 sequence_number = 5;
inline void Payload::clear_sequence_number() {
  sequence_number_ = 0u;
}
inline uint32_t Payload::_internal_sequence_number() const {
  return sequence_number_;
}
inline uint32_t Payload::sequence_number() const {
  // @@protoc_insertion_point(field_get:rtype.Payload.sequence_number)
  return _internal_sequence_number();
}
inline void Payload::_internal_set_sequence_number(uint32_t value) {
  
  sequence_number_ = value;
}
inline void Payload::set_sequence_number(uint32_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:rtype.Payload.sequence_number)
}

inline bool Payload::has_payload_type() const {
  return payload_type_case() != PAYLOAD_TYPE_NOT_SET;
}
inline void Payload::clear_has_payload_type() {
  _oneof_case_[0] = PAYLOAD_TYPE_NOT_SET;
}
inline Payload::PayloadTypeCase Payload::payload_type_case() const {
  return Payload::PayloadTypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rtype

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::rtype::EventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rtype::EventType>() {
  return ::rtype::EventType_descriptor();
}
template <> struct is_proto_enum< ::rtype::ConnectResponseStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rtype::ConnectResponseStatus>() {
  return ::rtype::ConnectResponseStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_r_5ftype_2eproto
